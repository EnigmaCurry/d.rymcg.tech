#!/bin/bash
## Build a raw disk image for the NixOS workstation USB
## Uses loop devices instead of QEMU to avoid build VM issues.
set -eo pipefail

BIN=$(dirname $(realpath ${BASH_SOURCE}))
ROOT_DIR=$(dirname ${BIN})
source ${BIN}/funcs.sh

IMAGE_DIR="${ROOT_DIR}/_archive"
IMAGE_FILE="${IMAGE_DIR}/workstation-usb.img"
IMAGE_SIZE=""
BASE_ONLY=""
DRY_RUN=""

usage() {
    echo "Usage: d.rymcg.tech workstation-usb-image [OPTIONS]"
    echo ""
    echo "Build a raw NixOS disk image for the workstation USB."
    echo "The image can be written to a USB drive with dd."
    echo "Requires sudo for loop device and mount operations."
    echo ""
    echo "By default, the image includes all archive data (Docker images,"
    echo "ISOs, Docker CE packages) found in _archive/. The image size is"
    echo "auto-calculated to fit everything plus headroom."
    echo ""
    echo "Options:"
    echo "  --size SIZE    Override auto-calculated image size (e.g. 128G)"
    echo "  --output FILE  Output path (default: ${IMAGE_FILE})"
    echo "  --base-only    Build OS only, without archive data (smaller image)"
    echo "  --dry-run      Build the system closure only, don't create image"
    echo "  -h, --help     Show this help"
    echo ""
    echo "After building:"
    echo "  sudo dd if=${IMAGE_FILE} of=/dev/sdX bs=4M status=progress conv=fsync"
    echo ""
    echo "The root partition auto-expands to fill the USB on first boot."
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --size)
            IMAGE_SIZE="$2"
            shift 2
            ;;
        --output)
            IMAGE_FILE="$2"
            shift 2
            ;;
        --base-only)
            BASE_ONLY=1
            shift
            ;;
        --dry-run)
            DRY_RUN=1
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
    esac
done

## Pre-flight check: show what will be included and offer to fetch missing data
if [[ -z "$BASE_ONLY" ]]; then
    echo "=== Pre-flight check ==="
    echo ""
    MISSING=()

    # Check Docker image archive
    ARCHIVE_IMG_DIR="${ROOT_DIR}/_archive/images/x86_64"
    if [[ -d "$ARCHIVE_IMG_DIR" ]] && [[ -n "$(ls -A "$ARCHIVE_IMG_DIR" 2>/dev/null)" ]]; then
        count=$(find "$ARCHIVE_IMG_DIR" -name '*.tar.gz' 2>/dev/null | wc -l)
        size=$(du -sh "$ARCHIVE_IMG_DIR" | cut -f1)
        echo "  [x] Docker image archive: $count images ($size)"
    else
        echo "  [ ] Docker image archive: not found"
        MISSING+=("images")
    fi

    # Check ISOs
    ISOS_DIR="${ROOT_DIR}/_archive/isos"
    if [[ -d "$ISOS_DIR" ]] && [[ -n "$(ls -A "$ISOS_DIR" 2>/dev/null)" ]]; then
        count=$(ls "$ISOS_DIR" | wc -l)
        size=$(du -sh "$ISOS_DIR" | cut -f1)
        echo "  [x] OS images (ISOs): $count files ($size)"
    else
        echo "  [ ] OS images (ISOs): not found"
        MISSING+=("isos")
    fi

    # Check Docker CE packages
    DOCKER_PKG_DIR="${ROOT_DIR}/_archive/docker-packages"
    if [[ -d "$DOCKER_PKG_DIR" ]] && [[ -n "$(ls -A "$DOCKER_PKG_DIR" 2>/dev/null)" ]]; then
        count=$(find "$DOCKER_PKG_DIR" -name '*.deb' -o -name '*.rpm' 2>/dev/null | wc -l)
        size=$(du -sh "$DOCKER_PKG_DIR" | cut -f1)
        echo "  [x] Docker CE packages: $count packages ($size)"
    else
        echo "  [ ] Docker CE packages: not found"
        MISSING+=("docker-packages")
    fi

    echo ""

    if [[ ${#MISSING[@]} -gt 0 ]]; then
        echo "Some archive data is missing. The image will be built without it"
        echo "unless you download it now."
        echo ""
        for item in "${MISSING[@]}"; do
            case "$item" in
                images)
                    if confirm no "Download Docker image archive? (requires d.rymcg.tech image-archive)"; then
                        d.rymcg.tech image-archive --fail-fast --delete --verbose
                    fi
                    ;;
                isos)
                    if confirm yes "Download OS images (ISOs)?"; then
                        d.rymcg.tech workstation-usb-download-isos
                    fi
                    ;;
                docker-packages)
                    if confirm yes "Download Docker CE packages?"; then
                        d.rymcg.tech workstation-usb-download-docker-packages
                    fi
                    ;;
            esac
        done
        echo ""
    else
        echo "All archive data present."
        echo ""
    fi
fi

echo "=== Building NixOS system closure ==="
SYSTEM_PATH=$(nix build "${ROOT_DIR}#nixosConfigurations.workstation.config.system.build.toplevel" --no-link --print-out-paths)
echo "System closure: $SYSTEM_PATH"

# Resolve nixos-install path from the system closure's dependencies
NIXOS_INSTALL=$(nix build "${ROOT_DIR}#nixosConfigurations.workstation.config.system.build.nixos-install" --no-link --print-out-paths)/bin/nixos-install
if [[ ! -x "$NIXOS_INSTALL" ]]; then
    echo "Error: nixos-install not found at $NIXOS_INSTALL" >&2
    exit 1
fi
echo "nixos-install: $NIXOS_INSTALL"

# Calculate sizes
echo ""
echo "=== Calculating image size ==="

# Get closure size in bytes
CLOSURE_BYTES=$(nix path-info -S "$SYSTEM_PATH" | awk '{print $2}')
CLOSURE_GB=$(awk "BEGIN {printf \"%.1f\", $CLOSURE_BYTES / 1073741824}")
echo "NixOS closure: ${CLOSURE_GB} GB"

ARCHIVE_BYTES=0
ARCHIVE_DIRS=""

if [[ -z "$BASE_ONLY" ]]; then
    # Measure archive directories
    for dir_info in \
        "Docker images:${ROOT_DIR}/_archive/images/x86_64" \
        "ISOs:${ROOT_DIR}/_archive/isos" \
        "Docker CE packages:${ROOT_DIR}/_archive/docker-packages"; do
        label="${dir_info%%:*}"
        dir="${dir_info#*:}"
        if [[ -d "$dir" ]] && [[ -n "$(ls -A "$dir" 2>/dev/null)" ]]; then
            dir_bytes=$(du -sb "$dir" | cut -f1)
            dir_gb=$(awk "BEGIN {printf \"%.1f\", $dir_bytes / 1073741824}")
            echo "$label: ${dir_gb} GB ($dir)"
            ARCHIVE_BYTES=$((ARCHIVE_BYTES + dir_bytes))
            ARCHIVE_DIRS="$ARCHIVE_DIRS $dir"
        else
            echo "$label: (not found, skipping)"
        fi
    done
fi

# Auto-calculate image size if not specified
if [[ -z "$IMAGE_SIZE" ]]; then
    # Total = closure + archive + 1GB ESP + 5GB headroom
    # nix store add roughly doubles storage temporarily, but we account for
    # the final on-disk size plus generous headroom
    TOTAL_BYTES=$((CLOSURE_BYTES + ARCHIVE_BYTES))
    # Add 1GB for ESP + 5GB headroom (or 15% of total, whichever is larger)
    HEADROOM_BYTES=$((5 * 1073741824))
    FIFTEEN_PCT=$((TOTAL_BYTES * 15 / 100))
    if [[ $FIFTEEN_PCT -gt $HEADROOM_BYTES ]]; then
        HEADROOM_BYTES=$FIFTEEN_PCT
    fi
    ESP_BYTES=$((1 * 1073741824))
    IMAGE_BYTES=$((TOTAL_BYTES + HEADROOM_BYTES + ESP_BYTES))
    # Round up to nearest GB
    IMAGE_GB=$(( (IMAGE_BYTES + 1073741823) / 1073741824 ))
    IMAGE_SIZE="${IMAGE_GB}G"
fi

echo ""
echo "Image size: $IMAGE_SIZE"

if [[ -n "$DRY_RUN" ]]; then
    echo ""
    echo "(dry run â€” system closure built, image not created)"
    exit 0
fi

echo ""
echo "=== Creating disk image ==="
echo "Image: ${IMAGE_FILE} (${IMAGE_SIZE})"
if [[ -z "$BASE_ONLY" ]]; then
    echo "Mode: full (includes archive data)"
else
    echo "Mode: base only (OS without archive data)"
fi
echo "This requires sudo for loop devices and mounting."
echo ""

mkdir -p "$(dirname "$IMAGE_FILE")"

POST_INSTALL_SCRIPT="${ROOT_DIR}/nix/workstation/installer/post-install.sh"

# The rest runs as root (pass PATH so nix tools work inside sudo)
exec sudo bash -c '
set -euo pipefail
export PATH="$5:$PATH"

IMAGE_FILE="$1"
IMAGE_SIZE="$2"
SYSTEM_PATH="$3"
NIXOS_INSTALL="$4"
BASE_ONLY="$6"
POST_INSTALL_SCRIPT="$7"

MOUNT=$(mktemp -d)
LOOP=""

cleanup() {
    set +e
    if [[ -n "$MOUNT" ]]; then
        umount -R "$MOUNT" 2>/dev/null
        rmdir "$MOUNT" 2>/dev/null
    fi
    if [[ -n "$LOOP" ]]; then
        losetup -d "$LOOP" 2>/dev/null
    fi
}
trap cleanup EXIT

# Create sparse image file
truncate -s "$IMAGE_SIZE" "$IMAGE_FILE"

# Set up loop device
LOOP=$(losetup --find --show --partscan "$IMAGE_FILE")
echo "Loop device: $LOOP"

# Partition: 1GB ESP + rest ext4
sgdisk --zap-all "$LOOP"
sgdisk -n 1:0:+1G -t 1:ef00 -c 1:ESP "$LOOP"
sgdisk -n 2:0:0 -t 2:8300 -c 2:nixos "$LOOP"
partprobe "$LOOP" || true
sleep 1

# Format
mkfs.fat -F32 -n ESP "${LOOP}p1"
mkfs.ext4 -L nixos -F "${LOOP}p2"

# Mount
mount "${LOOP}p2" "$MOUNT"
mkdir -p "$MOUNT/boot"
mount -o umask=0077 "${LOOP}p1" "$MOUNT/boot"

# Install NixOS
echo "=== Installing NixOS into image ==="
"$NIXOS_INSTALL" --system "$SYSTEM_PATH" --root "$MOUNT" --no-root-password --no-channel-copy

# Run post-install to copy archive data into the image
if [[ -z "$BASE_ONLY" ]] && [[ -x "$POST_INSTALL_SCRIPT" ]]; then
    echo ""
    echo "=== Copying archive data into image ==="
    "$POST_INSTALL_SCRIPT" "$MOUNT"
fi

# Unmount
umount -R "$MOUNT"
rmdir "$MOUNT"
MOUNT=""

# Detach loop
losetup -d "$LOOP"
LOOP=""

echo ""
echo "=== Image built successfully ==="
echo "Image: $IMAGE_FILE ($(du -h "$IMAGE_FILE" | cut -f1))"
echo ""
echo "Write to USB with:"
echo "  sudo dd if=$IMAGE_FILE of=/dev/sdX bs=4M status=progress conv=fsync"
echo ""
echo "The root partition auto-expands to fill the USB on first boot."
' _ "$IMAGE_FILE" "$IMAGE_SIZE" "$SYSTEM_PATH" "$NIXOS_INSTALL" "$PATH" "$BASE_ONLY" "$POST_INSTALL_SCRIPT"
