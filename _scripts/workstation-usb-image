#!/bin/bash
## Build a raw disk image for the NixOS workstation USB
## Uses loop devices instead of QEMU to avoid build VM issues.
set -eo pipefail

BIN=$(dirname $(realpath ${BASH_SOURCE}))
ROOT_DIR=$(dirname ${BIN})
source ${BIN}/funcs.sh

IMAGE_DIR="${ROOT_DIR}/_archive"
IMAGE_FILE=""
IMAGE_SIZE=""
BASE_ONLY=""
DRY_RUN=""
ARCHIVE_SOURCE="${ROOT_DIR}/_archive"
FILTERED_ARCHIVE=""
AI_ML_PROJECTS=(comfyui open-webui invokeai ollama kokoro)

usage() {
    echo "Usage: d.rymcg.tech workstation-usb-image [OPTIONS]"
    echo ""
    echo "Build a raw NixOS disk image for the workstation USB."
    echo "The image can be written to a USB drive with dd."
    echo "Requires sudo for loop device and mount operations."
    echo ""
    echo "By default, the image includes all archive data (Docker images,"
    echo "ISOs, Docker CE packages) found in _archive/. The image size is"
    echo "auto-calculated to fit everything plus headroom."
    echo ""
    echo "Options:"
    echo "  --size SIZE    Override auto-calculated image size (e.g. 128G)"
    echo "  --output FILE  Output path (default: _archive/workstation-usb.img,"
    echo "                 or _archive/workstation-usb-base.img with --base-only)"
    echo "  --base-only    Build OS only, without archive data (smaller image)"
    echo "  --dry-run      Build the system closure only, don't create image"
    echo "  -h, --help     Show this help"
    echo ""
    echo "After building, test in a VM or write to USB:"
    echo "  d.rymcg.tech workstation-usb-test-vm"
    echo "  sudo dd if=${IMAGE_FILE} of=/dev/sdX bs=4M status=progress conv=fsync"
    echo ""
    echo "The root partition auto-expands to fill the USB on first boot."
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --size)
            IMAGE_SIZE="$2"
            shift 2
            ;;
        --output)
            IMAGE_FILE="$2"
            shift 2
            ;;
        --base-only)
            BASE_ONLY=1
            shift
            ;;
        --dry-run)
            DRY_RUN=1
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
    esac
done

# Apply default output path based on mode
if [[ -z "$IMAGE_FILE" ]]; then
    if [[ -n "$BASE_ONLY" ]]; then
        IMAGE_FILE="${IMAGE_DIR}/workstation-usb-base.img"
    else
        IMAGE_FILE="${IMAGE_DIR}/workstation-usb.img"
    fi
fi

## Pre-flight check: show what will be included and offer to fetch missing data
if [[ -z "$BASE_ONLY" ]]; then
    echo "=== Pre-flight check ==="
    echo ""
    MISSING=()

    # Check Docker image archive
    ARCHIVE_IMG_DIR="${ROOT_DIR}/_archive/images/x86_64"
    if [[ -d "$ARCHIVE_IMG_DIR" ]] && [[ -n "$(ls -A "$ARCHIVE_IMG_DIR" 2>/dev/null)" ]]; then
        count=$(find "$ARCHIVE_IMG_DIR" -name '*.tar.gz' 2>/dev/null | wc -l)
        size=$(du -sh "$ARCHIVE_IMG_DIR" | cut -f1)
        echo "  [x] Docker image archive: $count images ($size)"
    else
        echo "  [ ] Docker image archive: not found"
        MISSING+=("images")
    fi

    # Check ISOs
    ISOS_DIR="${ROOT_DIR}/_archive/isos"
    if [[ -d "$ISOS_DIR" ]] && [[ -n "$(ls -A "$ISOS_DIR" 2>/dev/null)" ]]; then
        count=$(ls "$ISOS_DIR" | wc -l)
        size=$(du -sh "$ISOS_DIR" | cut -f1)
        echo "  [x] OS images (ISOs): $count files ($size)"
    else
        echo "  [ ] OS images (ISOs): not found"
        MISSING+=("isos")
    fi

    # Check Docker CE packages
    DOCKER_PKG_DIR="${ROOT_DIR}/_archive/docker-packages"
    if [[ -d "$DOCKER_PKG_DIR" ]] && [[ -n "$(ls -A "$DOCKER_PKG_DIR" 2>/dev/null)" ]]; then
        count=$(find "$DOCKER_PKG_DIR" -name '*.deb' -o -name '*.rpm' 2>/dev/null | wc -l)
        size=$(du -sh "$DOCKER_PKG_DIR" | cut -f1)
        echo "  [x] Docker CE packages: $count packages ($size)"
    else
        echo "  [ ] Docker CE packages: not found"
        MISSING+=("docker-packages")
    fi

    echo ""

    if [[ ${#MISSING[@]} -gt 0 ]]; then
        echo "Some archive data is missing. The image will be built without it"
        echo "unless you download it now."
        echo ""
        for item in "${MISSING[@]}"; do
            case "$item" in
                images)
                    if confirm no "Download Docker image archive? (requires d.rymcg.tech image-archive)"; then
                        d.rymcg.tech image-archive --fail-fast --delete --verbose
                    fi
                    ;;
                isos)
                    if confirm yes "Download OS images (ISOs)?"; then
                        d.rymcg.tech workstation-usb-download-isos
                    fi
                    ;;
                docker-packages)
                    if confirm yes "Download Docker CE packages?"; then
                        d.rymcg.tech workstation-usb-download-docker-packages
                    fi
                    ;;
            esac
        done
        echo ""
    else
        echo "All archive data present."
        echo ""
    fi

    ## Interactive archive category selection
    CATEGORY_LABELS=()
    CATEGORY_KEYS=()

    # Measure AI/ML images
    _AI_ML_SIZE=0
    _AI_ML_FOUND=false
    for proj in "${AI_ML_PROJECTS[@]}"; do
        proj_dir="$ARCHIVE_IMG_DIR/$proj"
        if [[ -d "$proj_dir" ]] && [[ -n "$(ls -A "$proj_dir" 2>/dev/null)" ]]; then
            _AI_ML_FOUND=true
            _AI_ML_SIZE=$((_AI_ML_SIZE + $(du -sb "$proj_dir" | cut -f1)))
        fi
    done
    if $_AI_ML_FOUND; then
        _ai_ml_gb=$(awk "BEGIN {printf \"%.1f\", $_AI_ML_SIZE / 1073741824}")
        CATEGORY_LABELS+=("Docker images: AI/ML ($_ai_ml_gb GB)")
        CATEGORY_KEYS+=("ai_ml")
    fi

    # Measure service images (everything not in AI_ML_PROJECTS)
    _SERVICES_SIZE=0
    _SERVICES_FOUND=false
    if [[ -d "$ARCHIVE_IMG_DIR" ]]; then
        for proj_dir in "$ARCHIVE_IMG_DIR"/*/; do
            [[ -d "$proj_dir" ]] || continue
            proj_name=$(basename "$proj_dir")
            if ! element_in_array "$proj_name" "${AI_ML_PROJECTS[@]}"; then
                if [[ -n "$(ls -A "$proj_dir" 2>/dev/null)" ]]; then
                    _SERVICES_FOUND=true
                    _SERVICES_SIZE=$((_SERVICES_SIZE + $(du -sb "$proj_dir" | cut -f1)))
                fi
            fi
        done
    fi
    if $_SERVICES_FOUND; then
        _services_gb=$(awk "BEGIN {printf \"%.1f\", $_SERVICES_SIZE / 1073741824}")
        CATEGORY_LABELS+=("Docker images: Services ($_services_gb GB)")
        CATEGORY_KEYS+=("services")
    fi

    # Measure ISOs
    if [[ -d "$ISOS_DIR" ]] && [[ -n "$(ls -A "$ISOS_DIR" 2>/dev/null)" ]]; then
        _isos_bytes=$(du -sb "$ISOS_DIR" | cut -f1)
        _isos_gb=$(awk "BEGIN {printf \"%.1f\", $_isos_bytes / 1073741824}")
        CATEGORY_LABELS+=("OS images / ISOs ($_isos_gb GB)")
        CATEGORY_KEYS+=("isos")
    fi

    # Measure Docker CE packages
    if [[ -d "$DOCKER_PKG_DIR" ]] && [[ -n "$(ls -A "$DOCKER_PKG_DIR" 2>/dev/null)" ]]; then
        _docker_pkg_bytes=$(du -sb "$DOCKER_PKG_DIR" | cut -f1)
        _docker_pkg_mb=$(awk "BEGIN {printf \"%.0f\", $_docker_pkg_bytes / 1048576}")
        CATEGORY_LABELS+=("Docker CE packages ($_docker_pkg_mb MB)")
        CATEGORY_KEYS+=("docker_packages")
    fi

    if [[ ${#CATEGORY_LABELS[@]} -gt 0 ]]; then
        echo "=== Select archive categories ==="
        echo "Deselect categories you don't need to reduce image size."
        echo ""

        # All selected by default
        _DEFAULT_JSON=$(printf '%s\n' "${CATEGORY_LABELS[@]}" | jq -R . | jq -s -c .)
        _exit_code=0
        SELECTED_OUTPUT=$(wizard select --cancel-code=2 --default "$_DEFAULT_JSON" \
            "Select categories to include:" "${CATEGORY_LABELS[@]}") && _exit_code=$? || _exit_code=$?
        if [[ "$_exit_code" == "2" ]]; then
            cancel
        fi
        readarray -t SELECTED <<< "$SELECTED_OUTPUT"

        # Determine what was selected
        INCLUDE_AI_ML=false
        INCLUDE_SERVICES=false
        INCLUDE_ISOS=false
        INCLUDE_DOCKER_PACKAGES=false

        for sel in "${SELECTED[@]}"; do
            case "$sel" in
                "Docker images: AI/ML"*) INCLUDE_AI_ML=true ;;
                "Docker images: Services"*) INCLUDE_SERVICES=true ;;
                "OS images / ISOs"*) INCLUDE_ISOS=true ;;
                "Docker CE packages"*) INCLUDE_DOCKER_PACKAGES=true ;;
            esac
        done

        ## ComfyUI GPU variant selection
        COMFYUI_SELECTED_FILES=()
        COMFYUI_DIR="$ARCHIVE_IMG_DIR/comfyui"
        if $INCLUDE_AI_ML && [[ -d "$COMFYUI_DIR" ]] && [[ -n "$(ls -A "$COMFYUI_DIR" 2>/dev/null)" ]]; then
            VARIANT_LABELS=()
            VARIANT_FILES=()
            for f in "$COMFYUI_DIR"/comfyui-comfyui-*_latest.tar.gz; do
                [[ -f "$f" ]] || continue
                fname=$(basename "$f")
                variant=$(echo "$fname" | sed 's/comfyui-comfyui-\(.*\)_latest\.tar\.gz/\1/')
                case "$variant" in
                    rocm) variant_label="ROCm" ;;
                    cuda) variant_label="CUDA" ;;
                    intel) variant_label="Intel" ;;
                    cpu) variant_label="CPU" ;;
                    *) variant_label="$variant" ;;
                esac
                file_size=$(du -sh "$f" | cut -f1)
                VARIANT_LABELS+=("ComfyUI $variant_label ($file_size)")
                VARIANT_FILES+=("$fname")
            done

            if [[ ${#VARIANT_LABELS[@]} -gt 1 ]]; then
                echo ""
                _VARIANT_DEFAULT_JSON=$(printf '%s\n' "${VARIANT_LABELS[@]}" | jq -R . | jq -s -c .)
                _exit_code=0
                VARIANT_OUTPUT=$(wizard select --cancel-code=2 --default "$_VARIANT_DEFAULT_JSON" \
                    "Select ComfyUI GPU variants:" "${VARIANT_LABELS[@]}") && _exit_code=$? || _exit_code=$?
                if [[ "$_exit_code" == "2" ]]; then
                    cancel
                fi
                readarray -t SELECTED_VARIANTS <<< "$VARIANT_OUTPUT"

                for i in "${!VARIANT_LABELS[@]}"; do
                    for sel in "${SELECTED_VARIANTS[@]}"; do
                        if [[ "$sel" == "${VARIANT_LABELS[$i]}" ]]; then
                            COMFYUI_SELECTED_FILES+=("${VARIANT_FILES[$i]}")
                        fi
                    done
                done
            else
                # Only one variant available, include it
                COMFYUI_SELECTED_FILES=("${VARIANT_FILES[@]}")
            fi
        fi

        ## Build filtered archive directory with symlinks
        FILTERED_ARCHIVE=$(mktemp -d)
        trap 'rm -rf "${FILTERED_ARCHIVE:-}"' EXIT

        if $INCLUDE_AI_ML || $INCLUDE_SERVICES; then
            mkdir -p "$FILTERED_ARCHIVE/images/x86_64"
        fi

        if $INCLUDE_AI_ML; then
            for proj in "${AI_ML_PROJECTS[@]}"; do
                proj_dir="$ARCHIVE_IMG_DIR/$proj"
                [[ -d "$proj_dir" ]] || continue
                [[ -n "$(ls -A "$proj_dir" 2>/dev/null)" ]] || continue

                if [[ "$proj" == "comfyui" ]] && [[ ${#COMFYUI_SELECTED_FILES[@]} -gt 0 ]]; then
                    # Create dir with only selected GPU variants
                    mkdir -p "$FILTERED_ARCHIVE/images/x86_64/comfyui"
                    for variant_file in "${COMFYUI_SELECTED_FILES[@]}"; do
                        ln -s "$COMFYUI_DIR/$variant_file" "$FILTERED_ARCHIVE/images/x86_64/comfyui/"
                    done
                elif [[ "$proj" != "comfyui" ]]; then
                    ln -s "$proj_dir" "$FILTERED_ARCHIVE/images/x86_64/$proj"
                fi
            done
        fi

        if $INCLUDE_SERVICES; then
            for proj_dir in "$ARCHIVE_IMG_DIR"/*/; do
                [[ -d "$proj_dir" ]] || continue
                proj_name=$(basename "$proj_dir")
                if ! element_in_array "$proj_name" "${AI_ML_PROJECTS[@]}"; then
                    ln -s "$proj_dir" "$FILTERED_ARCHIVE/images/x86_64/$proj_name"
                fi
            done
        fi

        if $INCLUDE_ISOS; then
            ln -s "$ISOS_DIR" "$FILTERED_ARCHIVE/isos"
        fi

        if $INCLUDE_DOCKER_PACKAGES; then
            ln -s "$DOCKER_PKG_DIR" "$FILTERED_ARCHIVE/docker-packages"
        fi

        ARCHIVE_SOURCE="$FILTERED_ARCHIVE"
        echo ""
    fi
fi

echo "=== Build summary ==="
echo "Output: $IMAGE_FILE"
if [[ -n "$BASE_ONLY" ]]; then
    echo "Mode: base only (OS without archive data)"
else
    echo "Mode: full (OS + archive data)"
fi
if [[ -n "$IMAGE_SIZE" ]]; then
    echo "Size: $IMAGE_SIZE (manual override)"
else
    # Estimate image size before building (closure ~10GB + archive data + headroom)
    ESTIMATE_BYTES=$((10 * 1073741824))  # ~10 GB base closure estimate
    if [[ -z "$BASE_ONLY" ]]; then
        for dir in \
            "${ARCHIVE_SOURCE}/images/x86_64" \
            "${ARCHIVE_SOURCE}/isos" \
            "${ARCHIVE_SOURCE}/docker-packages"; do
            if [[ -d "$dir" ]] && [[ -n "$(ls -A "$dir" 2>/dev/null)" ]]; then
                ESTIMATE_BYTES=$((ESTIMATE_BYTES + $(du -sbL "$dir" | cut -f1)))
            fi
        done
    fi
    # Add 1GB ESP + 15% headroom (or 5GB min)
    HEADROOM=$((ESTIMATE_BYTES * 15 / 100))
    [[ $HEADROOM -lt $((5 * 1073741824)) ]] && HEADROOM=$((5 * 1073741824))
    ESTIMATE_BYTES=$((ESTIMATE_BYTES + HEADROOM + 1073741824))
    ESTIMATE_GB=$(( (ESTIMATE_BYTES + 1073741823) / 1073741824 ))
    echo "Size: ~${ESTIMATE_GB} GB (estimated, exact size calculated after build)"
fi
echo ""
confirm yes "Build the image" "?" || exit 0

echo ""
echo "=== Building NixOS system closure ==="
SYSTEM_PATH=$(nix build "${ROOT_DIR}#nixosConfigurations.workstation.config.system.build.toplevel" --no-link --print-out-paths)
echo "System closure: $SYSTEM_PATH"

# Resolve nixos-install path from the system closure's dependencies
NIXOS_INSTALL=$(nix build "${ROOT_DIR}#nixosConfigurations.workstation.config.system.build.nixos-install" --no-link --print-out-paths)/bin/nixos-install
if [[ ! -x "$NIXOS_INSTALL" ]]; then
    echo "Error: nixos-install not found at $NIXOS_INSTALL" >&2
    exit 1
fi
echo "nixos-install: $NIXOS_INSTALL"

# Calculate sizes
echo ""
echo "=== Calculating image size ==="

# Get closure size in bytes
CLOSURE_BYTES=$(nix path-info -S "$SYSTEM_PATH" | awk '{print $2}')
CLOSURE_GB=$(awk "BEGIN {printf \"%.1f\", $CLOSURE_BYTES / 1073741824}")
echo "NixOS closure: ${CLOSURE_GB} GB"

ARCHIVE_BYTES=0
ARCHIVE_DIRS=""

if [[ -z "$BASE_ONLY" ]]; then
    # Measure archive directories
    for dir_info in \
        "Docker images:${ARCHIVE_SOURCE}/images/x86_64" \
        "ISOs:${ARCHIVE_SOURCE}/isos" \
        "Docker CE packages:${ARCHIVE_SOURCE}/docker-packages"; do
        label="${dir_info%%:*}"
        dir="${dir_info#*:}"
        if [[ -d "$dir" ]] && [[ -n "$(ls -A "$dir" 2>/dev/null)" ]]; then
            dir_bytes=$(du -sbL "$dir" | cut -f1)
            dir_gb=$(awk "BEGIN {printf \"%.1f\", $dir_bytes / 1073741824}")
            echo "$label: ${dir_gb} GB ($dir)"
            ARCHIVE_BYTES=$((ARCHIVE_BYTES + dir_bytes))
            ARCHIVE_DIRS="$ARCHIVE_DIRS $dir"
        else
            echo "$label: (not found, skipping)"
        fi
    done
fi

# Auto-calculate image size if not specified
if [[ -z "$IMAGE_SIZE" ]]; then
    # Total = closure + archive + 1GB ESP + 5GB headroom
    # nix store add roughly doubles storage temporarily, but we account for
    # the final on-disk size plus generous headroom
    TOTAL_BYTES=$((CLOSURE_BYTES + ARCHIVE_BYTES))
    # Add 1GB for ESP + 5GB headroom (or 15% of total, whichever is larger)
    HEADROOM_BYTES=$((5 * 1073741824))
    FIFTEEN_PCT=$((TOTAL_BYTES * 15 / 100))
    if [[ $FIFTEEN_PCT -gt $HEADROOM_BYTES ]]; then
        HEADROOM_BYTES=$FIFTEEN_PCT
    fi
    ESP_BYTES=$((1 * 1073741824))
    IMAGE_BYTES=$((TOTAL_BYTES + HEADROOM_BYTES + ESP_BYTES))
    # Round up to nearest GB
    IMAGE_GB=$(( (IMAGE_BYTES + 1073741823) / 1073741824 ))
    IMAGE_SIZE="${IMAGE_GB}G"
fi

echo ""
echo "Image size: $IMAGE_SIZE"

if [[ -n "$DRY_RUN" ]]; then
    echo ""
    echo "(dry run â€” system closure built, image not created)"
    exit 0
fi

echo ""
echo "=== Creating disk image ==="
echo "Image: ${IMAGE_FILE} (${IMAGE_SIZE})"
if [[ -z "$BASE_ONLY" ]]; then
    echo "Mode: full (includes archive data)"
else
    echo "Mode: base only (OS without archive data)"
fi
echo "This requires sudo for loop devices and mounting."
echo ""

mkdir -p "$(dirname "$IMAGE_FILE")"

POST_INSTALL_SCRIPT="${ROOT_DIR}/nix/workstation/installer/post-install.sh"

# The rest runs as root (pass PATH so nix tools work inside sudo)
exec sudo bash -c '
set -euo pipefail
export PATH="$5:$PATH"

IMAGE_FILE="$1"
IMAGE_SIZE="$2"
SYSTEM_PATH="$3"
NIXOS_INSTALL="$4"
BASE_ONLY="$6"
POST_INSTALL_SCRIPT="$7"
ARCHIVE_SOURCE="$8"

MOUNT=$(mktemp -d)
LOOP=""

cleanup() {
    set +e
    if [[ -n "$MOUNT" ]]; then
        umount -R "$MOUNT" 2>/dev/null
        rmdir "$MOUNT" 2>/dev/null
    fi
    if [[ -n "$LOOP" ]]; then
        losetup -d "$LOOP" 2>/dev/null
    fi
    if [[ -n "${ARCHIVE_SOURCE:-}" ]] && [[ "$ARCHIVE_SOURCE" == /tmp/* ]]; then
        rm -rf "$ARCHIVE_SOURCE" 2>/dev/null
    fi
}
trap cleanup EXIT

# Create sparse image file
truncate -s "$IMAGE_SIZE" "$IMAGE_FILE"

# Set up loop device
LOOP=$(losetup --find --show --partscan "$IMAGE_FILE")
echo "Loop device: $LOOP"

# Partition: 1GB ESP + rest ext4
sgdisk --zap-all "$LOOP"
sgdisk -n 1:0:+1G -t 1:ef00 -c 1:ESP "$LOOP"
sgdisk -n 2:0:0 -t 2:8300 -c 2:nixos "$LOOP"
partprobe "$LOOP" || true
sleep 1

# Format
mkfs.fat -F32 -n ESP "${LOOP}p1"
mkfs.ext4 -L nixos -F "${LOOP}p2"

# Mount
mount "${LOOP}p2" "$MOUNT"
mkdir -p "$MOUNT/boot"
mount -o umask=0077 "${LOOP}p1" "$MOUNT/boot"

# Install NixOS
echo "=== Installing NixOS into image ==="
"$NIXOS_INSTALL" --system "$SYSTEM_PATH" --root "$MOUNT" --no-root-password --no-channel-copy

# Run post-install to copy archive data into the image
if [[ -z "$BASE_ONLY" ]] && [[ -x "$POST_INSTALL_SCRIPT" ]]; then
    echo ""
    echo "=== Copying archive data into image ==="
    "$POST_INSTALL_SCRIPT" "$MOUNT" "$ARCHIVE_SOURCE"
fi

# Unmount
umount -R "$MOUNT"
rmdir "$MOUNT"
MOUNT=""

# Detach loop
losetup -d "$LOOP"
LOOP=""

echo ""
echo "=== Image built successfully ==="
echo "Image: $IMAGE_FILE ($(du -h "$IMAGE_FILE" | cut -f1))"
echo ""
echo "Write to USB with:"
echo "  sudo dd if=$IMAGE_FILE of=/dev/sdX bs=4M status=progress conv=fsync"
echo ""
echo "The root partition auto-expands to fill the USB on first boot."
' _ "$IMAGE_FILE" "$IMAGE_SIZE" "$SYSTEM_PATH" "$NIXOS_INSTALL" "$PATH" "$BASE_ONLY" "$POST_INSTALL_SCRIPT" "$ARCHIVE_SOURCE"
