#!/bin/bash
## Build a raw disk image for the NixOS workstation USB
## Uses loop devices instead of QEMU to avoid build VM issues.
set -eo pipefail

BIN=$(dirname $(realpath ${BASH_SOURCE}))
ROOT_DIR=$(dirname ${BIN})
source ${BIN}/funcs.sh
source ${BIN}/workstation-build-lib.sh

IMAGE_DIR="${ROOT_DIR}/_archive"
IMAGE_FILE=""
IMAGE_SIZE=""
BASE_ONLY=""
DRY_RUN=""
ARCHIVE_SOURCE="${ROOT_DIR}/_archive"
MANIFEST_FILE=""

usage() {
    echo "Usage: d.rymcg.tech workstation-usb-image [OPTIONS]"
    echo ""
    echo "Build a raw NixOS disk image for the workstation USB."
    echo "The image can be written to a USB drive with dd."
    echo "Requires sudo for loop device and mount operations."
    echo ""
    echo "By default, the image includes all archive data (Docker images,"
    echo "ISOs, Docker CE packages) found in _archive/. The image size is"
    echo "auto-calculated to fit everything plus headroom."
    echo ""
    echo "Options:"
    echo "  --size SIZE    Override auto-calculated image size (e.g. 128G)"
    echo "  --output FILE  Output path (default: _archive/workstation-usb.img,"
    echo "                 or _archive/workstation-usb-base.img with --base-only)"
    echo "  --base-only    Build OS only, without archive data (smaller image)"
    echo "  --dry-run      Build the system closure only, don't create image"
    echo "  -h, --help     Show this help"
    echo ""
    echo "After building, test in a VM or write to USB:"
    echo "  d.rymcg.tech workstation-usb-test-vm"
    echo "  sudo dd if=${IMAGE_FILE} of=/dev/sdX bs=4M status=progress conv=fsync"
    echo ""
    echo "The root partition auto-expands to fill the USB on first boot."
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --size)
            IMAGE_SIZE="$2"
            shift 2
            ;;
        --output)
            IMAGE_FILE="$2"
            shift 2
            ;;
        --base-only)
            BASE_ONLY=1
            shift
            ;;
        --dry-run)
            DRY_RUN=1
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
    esac
done

# Apply default output path based on mode
if [[ -z "$IMAGE_FILE" ]]; then
    if [[ -n "$BASE_ONLY" ]]; then
        IMAGE_FILE="${IMAGE_DIR}/workstation-usb-base.img"
    else
        IMAGE_FILE="${IMAGE_DIR}/workstation-usb.img"
    fi
fi

if [[ -z "$BASE_ONLY" ]]; then
    workstation_archive_preflight
    workstation_archive_select
else
    # --base-only: empty manifest (no archive data, but still run chroot tasks)
    SELECTED_IMAGE_PROJECTS=()
    COMFYUI_SELECTED_FILES=()
    INCLUDE_ISOS=false
    INCLUDE_DOCKER_PACKAGES=false
    MANIFEST_FILE=$(mktemp)
    {
        echo "ARCHIVE_ROOT=\"${ARCHIVE_SOURCE}\""
        echo "IMAGE_PROJECTS=\"\""
        echo "COMFYUI_FILES=\"\""
        echo "INCLUDE_ISOS=false"
        echo "INCLUDE_DOCKER_PACKAGES=false"
    } > "$MANIFEST_FILE"
fi

workstation_configure_settings

echo "=== Build summary ==="
echo "Output: $IMAGE_FILE"
if [[ -n "$BASE_ONLY" ]]; then
    echo "Mode: base only (OS without archive data)"
else
    echo "Mode: full (OS + archive data)"
fi
if [[ -n "$IMAGE_SIZE" ]]; then
    echo "Size: $IMAGE_SIZE (manual override)"
else
    # Estimate image size before building (closure ~10GB + archive data + headroom)
    ESTIMATE_BYTES=$((10 * 1073741824))  # ~10 GB base closure estimate
    if [[ -z "$BASE_ONLY" ]]; then
        for proj in "${SELECTED_IMAGE_PROJECTS[@]}"; do
            proj_dir="$ARCHIVE_IMG_DIR/$proj"
            [[ -d "$proj_dir" ]] && ESTIMATE_BYTES=$((ESTIMATE_BYTES + $(du -sbL "$proj_dir" | cut -f1)))
        done
        for f in "${COMFYUI_SELECTED_FILES[@]}"; do
            [[ -f "$ARCHIVE_IMG_DIR/comfyui/$f" ]] && ESTIMATE_BYTES=$((ESTIMATE_BYTES + $(stat -c%s "$ARCHIVE_IMG_DIR/comfyui/$f")))
        done
        if ${INCLUDE_ISOS:-false} && [[ -d "${ISOS_DIR:-}" ]]; then
            ESTIMATE_BYTES=$((ESTIMATE_BYTES + $(du -sbL "$ISOS_DIR" | cut -f1)))
        fi
        if ${INCLUDE_DOCKER_PACKAGES:-false} && [[ -d "${DOCKER_PKG_DIR:-}" ]]; then
            ESTIMATE_BYTES=$((ESTIMATE_BYTES + $(du -sbL "$DOCKER_PKG_DIR" | cut -f1)))
        fi
    fi
    # Add 1GB ESP + 25% headroom (or 8GB min)
    HEADROOM=$((ESTIMATE_BYTES * 25 / 100))
    [[ $HEADROOM -lt $((8 * 1073741824)) ]] && HEADROOM=$((8 * 1073741824))
    ESTIMATE_BYTES=$((ESTIMATE_BYTES + HEADROOM + 1073741824))
    ESTIMATE_GB=$(( (ESTIMATE_BYTES + 1073741823) / 1073741824 ))
    echo "Size: ~${ESTIMATE_GB} GB (estimated, exact size calculated after build)"
fi
echo ""
confirm yes "Build the image" "?" || exit 0

# Acquire sudo early so the credential is cached for the disk image step later
sudo true

echo ""
workstation_create_bare_repos

echo ""
echo "=== Building NixOS system closure ==="
SYSTEM_PATH=$(workstation_nix_build "nixosConfigurations.workstation.config.system.build.toplevel")
echo "System closure: $SYSTEM_PATH"

# Resolve nixos-install path from the system closure's dependencies
NIXOS_INSTALL=$(workstation_nix_build "nixosConfigurations.workstation.config.system.build.nixos-install")/bin/nixos-install
if [[ ! -x "$NIXOS_INSTALL" ]]; then
    echo "Error: nixos-install not found at $NIXOS_INSTALL" >&2
    exit 1
fi
echo "nixos-install: $NIXOS_INSTALL"

# Now that nix has read settings.nix, hide it from git status
workstation_hide_settings

# Calculate sizes
echo ""
echo "=== Calculating image size ==="

# Get closure size in bytes
CLOSURE_BYTES=$(nix path-info -S "$SYSTEM_PATH" | awk '{print $2}')
CLOSURE_GB=$(awk "BEGIN {printf \"%.1f\", $CLOSURE_BYTES / 1073741824}")
echo "NixOS closure: ${CLOSURE_GB} GB"

ARCHIVE_BYTES=0

if [[ -z "$BASE_ONLY" ]]; then
    _img_bytes=0
    for proj in "${SELECTED_IMAGE_PROJECTS[@]}"; do
        proj_dir="$ARCHIVE_IMG_DIR/$proj"
        [[ -d "$proj_dir" ]] && _img_bytes=$((_img_bytes + $(du -sbL "$proj_dir" | cut -f1)))
    done
    for f in "${COMFYUI_SELECTED_FILES[@]}"; do
        [[ -f "$ARCHIVE_IMG_DIR/comfyui/$f" ]] && _img_bytes=$((_img_bytes + $(stat -c%s "$ARCHIVE_IMG_DIR/comfyui/$f")))
    done
    if [[ $_img_bytes -gt 0 ]]; then
        _img_gb=$(awk "BEGIN {printf \"%.1f\", $_img_bytes / 1073741824}")
        echo "Docker images: ${_img_gb} GB"
        ARCHIVE_BYTES=$((ARCHIVE_BYTES + _img_bytes))
    else
        echo "Docker images: (none selected)"
    fi

    if ${INCLUDE_ISOS:-false} && [[ -d "${ISOS_DIR:-}" ]] && [[ -n "$(ls -A "$ISOS_DIR" 2>/dev/null)" ]]; then
        dir_bytes=$(du -sbL "$ISOS_DIR" | cut -f1)
        dir_gb=$(awk "BEGIN {printf \"%.1f\", $dir_bytes / 1073741824}")
        echo "ISOs: ${dir_gb} GB"
        ARCHIVE_BYTES=$((ARCHIVE_BYTES + dir_bytes))
    fi

    if ${INCLUDE_DOCKER_PACKAGES:-false} && [[ -d "${DOCKER_PKG_DIR:-}" ]] && [[ -n "$(ls -A "$DOCKER_PKG_DIR" 2>/dev/null)" ]]; then
        dir_bytes=$(du -sbL "$DOCKER_PKG_DIR" | cut -f1)
        dir_gb=$(awk "BEGIN {printf \"%.1f\", $dir_bytes / 1073741824}")
        echo "Docker CE packages: ${dir_gb} GB"
        ARCHIVE_BYTES=$((ARCHIVE_BYTES + dir_bytes))
    fi
fi

# Auto-calculate image size if not specified
if [[ -z "$IMAGE_SIZE" ]]; then
    # Total = closure + archive + 1GB ESP + headroom
    # Headroom covers: ext4/nix overhead, chroot tasks (emacs packages,
    # Rust toolchain), and general breathing room.
    TOTAL_BYTES=$((CLOSURE_BYTES + ARCHIVE_BYTES))
    # Add 1GB for ESP + 8GB headroom (or 20% of total, whichever is larger)
    HEADROOM_BYTES=$((8 * 1073741824))
    PCT_HEADROOM=$((TOTAL_BYTES * 25 / 100))
    if [[ $PCT_HEADROOM -gt $HEADROOM_BYTES ]]; then
        HEADROOM_BYTES=$PCT_HEADROOM
    fi
    ESP_BYTES=$((1 * 1073741824))
    IMAGE_BYTES=$((TOTAL_BYTES + HEADROOM_BYTES + ESP_BYTES))
    # Round up to nearest GB
    IMAGE_GB=$(( (IMAGE_BYTES + 1073741823) / 1073741824 ))
    IMAGE_SIZE="${IMAGE_GB}G"
fi

echo ""
echo "Image size: $IMAGE_SIZE"

if [[ -n "$DRY_RUN" ]]; then
    echo ""
    echo "(dry run â€” system closure built, image not created)"
    exit 0
fi

echo ""
echo "=== Creating disk image ==="
echo "Image: ${IMAGE_FILE} (${IMAGE_SIZE})"
if [[ -z "$BASE_ONLY" ]]; then
    echo "Mode: full (includes archive data)"
else
    echo "Mode: base only (OS without archive data)"
fi
echo "This requires sudo for loop devices and mounting."
echo ""

mkdir -p "$(dirname "$IMAGE_FILE")"

POST_INSTALL_SCRIPT="${ROOT_DIR}/nix/workstation/installer/post-install.sh"

# The rest runs as root (pass values as positional args to avoid sudo env_reset)
exec sudo bash -c '
set -euo pipefail
IMAGE_FILE="$1"
IMAGE_SIZE="$2"
SYSTEM_PATH="$3"
NIXOS_INSTALL="$4"
export PATH="$5:$PATH"
BASE_ONLY="${6:-}"
POST_INSTALL_SCRIPT="$7"
MANIFEST_FILE="${8:-}"

MOUNT=$(mktemp -d)
LOOP=""

cleanup() {
    set +e
    if [[ -n "$MOUNT" ]]; then
        fuser -km "$MOUNT" 2>/dev/null || true
        sleep 1
        umount -lR "$MOUNT" 2>/dev/null || true
        rmdir "$MOUNT" 2>/dev/null
    fi
    if [[ -n "$LOOP" ]]; then
        losetup -d "$LOOP" 2>/dev/null
    fi
    if [[ -n "${MANIFEST_FILE:-}" ]] && [[ "$MANIFEST_FILE" == /tmp/* ]]; then
        rm -f "$MANIFEST_FILE" 2>/dev/null
    fi
}
trap cleanup EXIT

# Clean up stale loop devices from previous interrupted builds
STALE_LOOPS=$(losetup -l -n -O NAME,BACK-FILE 2>/dev/null | grep "workstation-usb" | awk "{print \$1}" || true)
if [[ -n "$STALE_LOOPS" ]]; then
    echo "Cleaning up stale loop devices from previous builds..."
    for stale in $STALE_LOOPS; do
        fuser -km "${stale}p2" 2>/dev/null || true
        fuser -km "${stale}p1" 2>/dev/null || true
    done
    sleep 1
    for stale in $STALE_LOOPS; do
        umount -l "${stale}p1" 2>/dev/null || true
        umount -l "${stale}p2" 2>/dev/null || true
        losetup -d "$stale" 2>/dev/null || true
    done
    echo "Cleaned up $(echo "$STALE_LOOPS" | wc -w) stale loop device(s)"
fi

# Create sparse image file
truncate -s "$IMAGE_SIZE" "$IMAGE_FILE"

# Set up loop device
LOOP=$(losetup --find --show --partscan "$IMAGE_FILE")
echo "Loop device: $LOOP"

# Partition: 1GB ESP + rest btrfs
sgdisk --zap-all "$LOOP"
sgdisk -n 1:0:+1G -t 1:ef00 -c 1:ESP "$LOOP"
sgdisk -n 2:0:0 -t 2:8300 -c 2:nixos "$LOOP"
partprobe "$LOOP" || true
sleep 1

# Format
mkfs.fat -F32 -n ESP "${LOOP}p1"
mkfs.btrfs -L nixos -f "${LOOP}p2"

# Mount
mount -o compress=zstd,noatime "${LOOP}p2" "$MOUNT"
mkdir -p "$MOUNT/boot"
mount -o umask=0077 "${LOOP}p1" "$MOUNT/boot"

# Install NixOS
echo "=== Installing NixOS into image ==="
"$NIXOS_INSTALL" --system "$SYSTEM_PATH" --root "$MOUNT" --no-root-password --no-channel-copy

# Run post-install tasks
if [[ -x "$POST_INSTALL_SCRIPT" ]]; then
    echo ""
    if [[ -z "$BASE_ONLY" ]]; then
        echo "=== Running post-install (archive data + chroot tasks) ==="
    else
        echo "=== Running post-install (chroot tasks, no archive data) ==="
    fi
    "$POST_INSTALL_SCRIPT" "$MOUNT" "$MANIFEST_FILE"
fi

# Sync all pending writes before unmounting
sync

# Unmount
umount "$MOUNT/boot" 2>/dev/null || true
umount "$MOUNT" 2>/dev/null || true
if mountpoint -q "$MOUNT" 2>/dev/null; then
    echo "Warning: mount point still busy, waiting..."
    sleep 3
    sync
    umount -R "$MOUNT" 2>/dev/null || umount -lR "$MOUNT" 2>/dev/null || true
    sleep 2
    sync
fi
rmdir "$MOUNT" 2>/dev/null || true
MOUNT=""

# Detach loop
sync
losetup -d "$LOOP"
LOOP=""

echo ""
echo "=== Image built successfully ==="
echo "Image: $IMAGE_FILE ($(du -h --apparent-size "$IMAGE_FILE" | cut -f1))"
echo ""
echo "Write to USB with:"
echo "  sudo dd if=$IMAGE_FILE of=/dev/sdX bs=4M status=progress conv=fsync"
echo ""
echo "The root partition auto-expands to fill the USB on first boot."
' _ "$IMAGE_FILE" "$IMAGE_SIZE" "$SYSTEM_PATH" "$NIXOS_INSTALL" "$PATH" "${BASE_ONLY:-}" "$POST_INSTALL_SCRIPT" "${MANIFEST_FILE:-}"
