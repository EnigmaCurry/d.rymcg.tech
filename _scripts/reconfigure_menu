#!/bin/bash

## reconfigure_menu OPTIONS PROMPT DEFAULT MIN MAX
## Ask a question with multiple possible options to select from
## OPTIONS: string, pipe-separated options
## PROMPT: string, question to be asked
## DEFAULT: integer, the # of the pipe-separated option that should be the default (first item in pipe-separated list is 1) (e.g., pipe-separated-options are "apple,banana,watermelon", their index #s are 1,2,3, DEFAULT=2 so the default option is "banana")
## DEFAULT may be a single - to indicate the default should be blank.
## MIN: optional, the minimum number of selections a user must make (if not provided, MIN=1)
## MAX: optional, the maximum number of selections a user can make (if not provided, MAX=MIN)
## If MIN or MAX > 1, DEFAULT is ignored
## Results stored in `menu_result`: index # of the option selected, or comma-separated index #s if more than 1 option allowed

BIN=$(dirname ${BASH_SOURCE})
source ${BIN}/funcs.sh
set -eo pipefail

## Set options
mapfile -t options < <(echo $1 | tr '|' '\n' | sed 's/^ *//; s/*$//')
if [[ "${#options[@]}" -le 1 ]]; then
	echo "No options to select from"
	exit 1
fi
## Set prompt
prompt=$2
## Set minimum # of options a user must select
if [[ -z "$4" || ! "$4" =~ ^[0-9]+$ ]]; then
	min=1
else
	min=$4
fi
## Set maximum # of options a user can select
if [[ -z "$5" || ! "$5" =~ ^[0-9]+$ ]]; then
	max="${min}"
elif [[ "$5" -le "${#options[@]}" ]]; then
	max=$5
else
	max="${#options[@]}"
fi
## assure MAX > MIN
if [[ ${min} > ${max} ]]; then
	echo "The maximum number of selections a user can make must be equal to or greater than the minimum."
	exit 1
fi
## Set default
if [[ -z "$3" || "$3" == "-" || ! "$3" =~ ^[0-9]+$ || ${min} > 1 || ${max} > 1 ]]; then
	default='';
else
	default=$3
fi

menu_prompt() {
	echo
	echo "${prompt}"
	for i in "${!options[@]}"; do
		echo "$((i+1))) ${options[i]}"
	done
	echo
}

get_selection() {
	answers=()
	## for each possible answer between MIN and MAX...
	for i in $(seq 1 ${max}); do
		## Set prompt2
		if [[ $min == 1 && $max == 1 ]]; then
			prompt2="Select 1"
			prompt_default=$(test -z ${default} && echo "" || echo "[${default}]")
		else
			prompt2="Select ${i} of up to ${max} (enter blank to finish selecting)"
			prompt_default=""
		fi
		## Get response
		while true; do
			read -e -p "${prompt2} ${prompt_default}"$'\x0a: ' answer
			## Repeat request for response if blank entry, unless MIN==1 and a default is set (otherwise entering a blank signals to end user entry)
			if [[ -n "${answer}" || ${i} -gt ${min} || ${max} -eq 1 ]]; then
				break
			fi
		done
		
		## If no answer entered...
		if [[ -z "${answer}" ]]; then
			## if this is the user's first entry or if they haven't yet entered the MIN entries...
			#if [[ ${i} -eq 1 || ${i} -le ${min} ]]; then
			if [[ ${i} -le ${min} ]]; then
				## assign DEFAULT if provided
				if [[ -n "${default}" ]]; then
					answers+="${default}"
				fi
			## if this is not the user's first entry
			else
				## a blank answer means they're done selecting
				break
			fi
		fi
		
		## Add user's entry to `answers` array 
		answers+=("${answer}")
		
	done
}

menu_prompt
get_selection

## reset vars
final_answers=()

## For each entry the user submitted...
for answer in "${answers[@]}"; do
	final_answer=""

	## For each OPTIONS...
	for i in "${!options[@]}"; do
		## If user entered the value of this option instead of its index, reset their answer to the index of this option
		if [[ "${answer}" == "${options[i]}" ]]; then
			final_answer=$((i + 1))
			break
		fi
		
		## If user typed this index value, there is no need to continue checking what they entered
		if [[ "${answer}" -eq $((i + 1)) ]]; then
			final_answer="${answer}"
			break
		fi
	done

	## If final_answer is not blank, add it to `final_answers` array 
	test -n "${answer}" && final_answers+=("${final_answer}")

done

# Convert `finals_answers` to comma-separated string
menu_result=$(IFS=,; echo "${final_answers[*]}")

#echo "${menu_result}" #debug
