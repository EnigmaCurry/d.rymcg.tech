#!/bin/bash
## The eponymous CLI script for the project d.rymcg.tech

## This script should be symlinked to a directory on your PATH. You
## may add the `user` subdirectory to your path, which contains a
## symlink prepared for you. DO NOT add the whole _scripts directory
## to your PATH, but only the _scripts/user subdirectory! DO NOT move
## this script, only make symlinks to it!
##
## For example (choose one or the other):
##
##   # Option 1 - This assumes ~/bin is already in your PATH:
##   ln -s ~/git/vendor/enigmacurry/d.rymcg.tech/_scripts/d.rymcg.tech ~/bin
##
##   # Option 2 - You would add this to the botom of your ~/.bashrc or ~/.profile
##   export PATH=~/git/vendor/enigmacurry/d.rymcg.tech/_scripts/user:${PATH}

set -eo pipefail

## BIN is the _scripts directory inside of d.rymcg.tech
BIN=$(dirname $(realpath ${BASH_SOURCE}))

## INFO_WORDS are keys to information that the completion script can ask for at runtime:
INFO_WORDS="INFO_WORDS ROOT_DIR"

## ROOT_DIR is the root path of the d.rymcg.tech project
## Validate that this script is running from the canonical location
ROOT_DIR=$(dirname ${BIN})
(test -f ${BIN}/funcs.sh && test -f ${ROOT_DIR}/Makefile && test -d ${ROOT_DIR}/traefik) || \
    (echo "Error: Invalid or corrupted d.rymcg.tech ROOT_DIR: ${ROOT_DIR}" >/dev/stderr
     echo "This script will not function properly if it has been moved." >/dev/stderr
     exit 1)

SHELL_CONTAINER_ROOT=${ROOT_DIR}/_terminal/nix
FULL_COMMAND_ARGS="$@"

source ${BIN}/funcs.sh

__help() {
    echo "Found ROOT_DIR=${ROOT_DIR}"
    echo ""
    echo "## Main d.rymcg.tech sub-commands - Optional arguments are printed in brackets [OPTIONAL_ARG]."
    (
        echo -e "cd [SUBDIR]\tEnter a sub-shell and go to the ROOT_DIR directory (or given subdirectory)."
        echo -e "create [PROJECT] [TEMPLATE]\tCreate a new external project from a template."
        echo -e "make [PROJECT] [ARGS ...]\tRun a \`make\` command for the given d.rymcg.tech project name (See \`list\`)."
        echo -e "context [DOCKER_CONTEXT]\tView or set the current docker context."
        echo -e "completion\tSetup TAB completion in your shell."
        echo -e "shell [--help]\tCreate a containerized pet workstation environment preconfigured for Docker devlopment"
    ) | expand -t 30
    echo ""
    echo "## Documentation sub-commands:"
    (
        echo -e "help\tShow this help screen"
        echo -e "list\tList available d.rymcg.tech projects"
        echo -e "\t(not including external projects, unless you symlink them into ROOT_DIR)"
        echo -e "readme\tOpen the main d.rymcg.tech README.md in your browser"
        echo -e "readme [PROJECT]\tOpen the README.md for the given project name (See \`list\`)."
        while IFS=' ' read -ra DOC_WORDS; do
            for word in "${DOC_WORDS[@]}"; do
                FILE_EXTENSION="md"
                test "${word}" == "license" && FILE_EXTENSION="txt"
                echo -e "readme ${word}\tOpen root documentation file: $(echo ${word} | tr '[:lower:]' '[:upper:']).${FILE_EXTENSION}"
            done
        done <<< "$(__d.rymcg.tech_documentation_words --lowercase | sed 's/readme//')"
        #echo -e "info\tInternal read-only information for shell completion support"
    ) | expand -t 30
}

__create() {
    name_pattern='^[a-zA-Z][a-zA-Z0-9_-]*$'
    if [[ $# -gt 0 ]]; then
        PROJECT_NAME="$1"
        if ! [[ "${PROJECT_NAME}" =~ $name_pattern ]]; then
            fault "Error: Invalid characters in PROJECT_NAME -- valid regex: ${name_pattern}"
        fi
    else
        echo "This script will create a new docker-compose project and integrate d.rymcg.tech Makefiles"
        while ! [[ "${PROJECT_NAME}" =~ $name_pattern ]]; do
            test -n "${PROJECT_NAME}" && echo "Error: Invalid characters in PROJECT_NAME -- valid regex: ${name_pattern}"
            ask_no_blank "Enter a name for the new docker-compose project" PROJECT_NAME
        done
        echo ""
    fi
    PROJECT_NAME=$(echo "$PROJECT_NAME" | tr ' ' '-')
    if [[ $# -gt 1 ]]; then
        TEMPLATE_NAME="$2"
    else
        echo "Available templates:"
        find "${ROOT_DIR}/_templates" -maxdepth 1 -type d -printf "%P\n" | grep -v "^_" | column
        echo ""
        ask_no_blank "Enter the template name to use" TEMPLATE_NAME
        echo ""
    fi
    ${BIN}/create "${PROJECT_NAME}" "${TEMPLATE_NAME}" "./${PROJECT_NAME}"
}

__change-directory() {
    echo "Entering sub-shell. Press Ctrl-D to pop back to the parent shell."
    if [[ $# -gt 0 ]]; then
        /bin/bash --rcfile <(echo "cd ${ROOT_DIR}/$1")
    else
        /bin/bash --rcfile <(echo "cd ${ROOT_DIR}")
    fi
    echo "Exited sub-shell."
}

__make() {
    if [[ $# -gt 0 ]]; then
        PROJECT_NAME="$1"; shift
        pattern="^-+$"
        if [[ "${PROJECT_NAME}" =~ $pattern ]]; then
            PROJECT_DIR=${ROOT_DIR}
        else
            PROJECT_DIR=${ROOT_DIR}/${PROJECT_NAME}
        fi
        test -d "${PROJECT_DIR}" || fault "Project directory does not exist: ${PROJECT_DIR}"
        make -C "${PROJECT_DIR}" "$@"
    else
        __list_projects
        error "Missing project name argument. Choose one from the above."
        error "To invoke the root Makefile use '-' as the name"
    fi
    DIR_NAME="$1"; shift
}

__list_projects() {
    (
        if [[ "$1" == "--raw" ]]; then
            find -L "${ROOT_DIR}" -maxdepth 1 -type d -printf "%P\n" | grep -v "^_" | grep -v "^\." | sort -u | xargs -iXX /bin/bash -c "test -f ${ROOT_DIR}/XX/Makefile && echo XX"
        else
            echo "List of available d.rymcg.tech projects (not including external projects):"
            echo ""
            set +e
            find "${ROOT_DIR}" -maxdepth 1 -type d -printf "%P\n" | grep -v "^_" | grep -v "^\." | sort -u | xargs -iXX /bin/bash -c "test -f ${ROOT_DIR}/XX/Makefile && echo XX" | column
            echo ""
        fi
    )
}

__readme() {
    if [[ $# -gt 0 ]]; then
        NAME="${1}"; shift
        NAME_UPPERCASE="$(echo "${NAME}" | tr '[:lower:]' '[:upper:]')"
        IFS=" " read -ra DOCS_ARRAY <<< "$(__d.rymcg.tech_documentation_words --uppercase)"
        declare -A DOCS_INDEX
        for doc in "${DOCS_ARRAY[@]}"; do
            DOCS_INDEX["${doc}"]="${doc}"
        done
        if [[ "${NAME_UPPERCASE}" == "LICENSE" ]]; then
            if ! command -v xdg-open; then
                exe less ${ROOT_DIR}/LICENSE.txt
            else
                exe xdg-open "https://github.com/EnigmaCurry/d.rymcg.tech/blob/master/LICENSE.txt"
            fi
        elif [[ -v DOCS_INDEX["${NAME_UPPERCASE}"] ]]; then
            if ! command -v xdg-open && command -v glow; then
                exe glow -p ${ROOT_DIR}/${NAME_UPPERCASE}.md
            else
                exe xdg-open "https://github.com/EnigmaCurry/d.rymcg.tech/blob/master/${NAME_UPPERCASE}.md#readme"
            fi
        else
            echo ${DOCS_INDEX["${NAME_UPPERCASE}"]}
            __make "${NAME}" readme "$@"
        fi
    else
        __make -- readme
    fi
}

__info() {
    if [[ $# == 0 ]]; then
        echo "## info returns read-only information about your d.rymcg.tech installation."
        echo "## This is an undocumented internal command for the completion scripts private use."
        echo "## Its behaviour is subject to change without notice."
        echo ""
        echo "## Available info keys:"
        IFS=" " read -ra WORDS <<< "${INFO_WORDS}"
        for word in "${WORDS[@]}"; do
            echo "${word}"
        done
        echo ""
    elif [[ "$1" == "ROOT_DIR" ]]; then
        echo "${ROOT_DIR}"
    elif [[ "$1" == "INFO_WORDS" ]]; then
        echo "${INFO_WORDS}"
    fi
}

__context() {
    if [[ $# == 0 ]]; then
        exe docker context ls
    else
        exe docker context use "$@"
    fi
}

__run_script() {
    CMD="${1}"; shift
    ${ROOT_DIR}/_scripts/${CMD} "$@"
}

__d.rymcg.tech_cli_alias() {
    local ALIAS="$1"
    alias $1='d.rymcg.tech'
    complete -F __d.rymcg.tech_completions $1
}

__d.rymcg.tech_shell_alias() {
    local ALIAS="$1"
    alias $1="d.rymcg.tech shell $1"
    complete -F __d.rymcg.tech_shell_completions $1
}


__d.rymcg.tech_project_alias() {
    local ROOT_DIR=$(d.rymcg.tech info ROOT_DIR)
    __ALIAS="${1}"
    __PROJECT_DIR="${2}"
    test -z "${__PROJECT_DIR}" && __PROJECT_DIR="${ROOT_DIR}/${__ALIAS}"
    export __ALIAS __PROJECT_DIR
    alias $1="make --no-print-directory -C ${__PROJECT_DIR}"
    read -r -d '' FUNC <<'EOF'
function _${__ALIAS}_complete {
    local __PROJECT_DIR=${__PROJECT_DIR}
    MAKE_TARGETS="$(make -C "${__PROJECT_DIR}" -qp 2>/dev/null | awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ {split($1,A,/ /);for(i in A)print A[i]}' | grep -v "^Makefile$" | sort -u)"
    if [[ ${COMP_CWORD} == 1 ]]; then
        COMPREPLY=($(compgen -W "${MAKE_TARGETS}" "${COMP_WORDS[1]}"))
    else
        COMPREPLY=()
    fi
}
EOF
    FUNC=$(echo "${FUNC}" | envsubst '${__ALIAS} ${__PROJECT_DIR}')
    eval "${FUNC}"
    complete -o filenames -F _${__ALIAS}_complete ${__ALIAS}
    unset __ALIAS __PROJECT_DIR
}

__d.rymcg.tech_completions() {
    ### BASH completion
    ## dev links:
    ### https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins
    ### https://iridakos.com/programming/2018/03/01/bash-programmable-completion-tutorial
    ### https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
    ## COMP_WORDS: an array of all the words typed
    ## COMP_CWORD: an index of the COMP_WORDS array pointing to the word the current cursor is at
    ## COMP_LINE: the current command line
    ## COMPREPLY is an array variable used to store the output completions
    ROOT_PROJECT_PLACEHOLDER="^-+$"
    INFO_WORDS=$(d.rymcg.tech info INFO_WORDS)
    ROOT_DIR=$(d.rymcg.tech info ROOT_DIR)

    if [[ ${COMP_CWORD} == 1 ]]; then
        ## Complete the main command:
        ## d.rymcg.tech <TAB> ...
        COMMANDS="help create cd make list readme info context completion shell"
        COMPREPLY=($(compgen -W "${COMMANDS}" "${COMP_WORDS[1]}"))
    elif [[ ${COMP_CWORD} == 2 ]]; then
        ALL_PROJECTS=$(d.rymcg.tech list --raw)
        ## Dispatch completion for the sub-command's first argument:
        ## d.rymcg.tech make <TAB> ...
        case ${COMP_WORDS[1]} in
            create)
                COMPREPLY=("#" "Type the project name");;
            cd)
                COMPREPLY=($(compgen -W "${ALL_PROJECTS}" "${COMP_WORDS[2]}"));;
            readme)
                COMPREPLY=($(compgen -W "$(__d.rymcg.tech_documentation_words) ${ALL_PROJECTS}" "${COMP_WORDS[2]}"));;
            make)
                COMPREPLY=($(compgen -W "-- ${ALL_PROJECTS}" "${COMP_WORDS[2]}"));;
            context)
                COMPREPLY=($(compgen -W "$(docker context ls --format '{{.Name}}')" "${COMP_WORDS[2]}"));;
            info)
                COMPREPLY=($(compgen -W "${INFO_WORDS}" "${COMP_WORDS[2]}"));;
            script)
                COMPREPLY=($(compgen -W "$(find ${ROOT_DIR}/_scripts -executable -printf '%P\n' | grep -v d.rymcg.tech)" "${COMP_WORDS[2]}"));;
            shell)
                COMPREPLY=($(compgen -W "$(__d.rymcg.tech_shell_words)" "'"${COMP_WORDS[2]}"'"));;
        esac
    elif [[ ${COMP_CWORD} == 3 ]]; then
        ## Dispatch completion for the sub-commands second argument:
        ## d.rymcg.tech make traefik <TAB> ...
        if [[ "${COMP_WORDS[1]}" == "make" ]]; then
            PROJECT=${COMP_WORDS[2]}
            PROJECT_DIR="${ROOT_DIR}/${PROJECT}"
            if [[ "${PROJECT}" =~ ${ROOT_PROJECT_PLACEHOLDER} ]]; then
                PROJECT_DIR="${ROOT_DIR}"
            fi
            ## Thanks Chris Down https://unix.stackexchange.com/a/230050
            MAKE_TARGETS="$(make -C "${PROJECT_DIR}" -qp 2>/dev/null | awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ {split($1,A,/ /);for(i in A)print A[i]}' | sort -u)"
            COMPREPLY=($(compgen -W "${MAKE_TARGETS}" "${COMP_WORDS[3]}"))
        elif [[ "${COMP_WORDS[1]}" == "create" ]]; then
            COMPREPLY=($(compgen -W "$(find ${ROOT_DIR}/_templates -maxdepth 1 -type d -printf "%P\n" | grep -v "^_")" "${COMP_WORDS[3]}"))
        elif [[ "${COMP_WORDS[1]}" == "shell" ]]; then
            COMPREPLY=($(compgen -W "$(__d.rymcg.tech_shell_words)" "'"${COMP_WORDS[3]}"'"))
        fi
    elif [[ ${COMP_CWORD} == 4 ]]; then
        if [[ "${COMP_WORDS[1]}" == "shell" ]]; then
            COMPREPLY=($(compgen -W "$(__d.rymcg.tech_shell_words)" "'"${COMP_WORDS[4]}"'"))
        fi
    fi
}

__d.rymcg.tech_shell_completions() {
    COMPREPLY=($(compgen -W "$(__d.rymcg.tech_shell_words)" "'"${COMP_WORDS[${COMP_CWORD}]}"'"))
}

__d.rymcg.tech_documentation_words() {
    ROOT_DIR=$(d.rymcg.tech info ROOT_DIR)
    ## Find list of available documentation files in the git repo:
    declare -A DOCS_INDEX
    while IFS= read -r line; do
        DOCS_INDEX["$line"]="$line"
    done <<< $(git -C "${ROOT_DIR}" ls-tree --name-only HEAD | \
                   grep -E "(\.txt$|\.md$)" | \
                   sed -e 's/\.txt$//' -e 's/\.md$//')
    if [[ "$1" == "--lowercase" ]]; then
        echo "$(echo ${DOCS_INDEX[@]} | tr '[:upper:]' '[:lower:]')"
    elif [[ "$1" == "--uppercase" ]]; then
        echo "$(echo ${DOCS_INDEX[@]} | tr '[:lower:]' '[:upper:]')"
    else
        echo "$(echo ${DOCS_INDEX[@]} | tr '[:lower:]' '[:upper:]') $(echo ${DOCS_INDEX[@]} | tr '[:upper:]' '[:lower:]')"
    fi
}

__completion() {
    # Print the completion script to be evaluated
    USER_SCRIPT_PATH=$(echo "${ROOT_DIR}/_scripts/user" | sed "s|${HOME}|\$\{HOME\}|")
    if [[ $# -lt 1 ]]; then
        echo "#### To enable BASH shell completion support for d.rymcg.tech,"
        echo "#### add the following lines into your ~/.bashrc ::"
        echo "export PATH=\${PATH}:${USER_SCRIPT_PATH}"
        echo 'eval "$(d.rymcg.tech completion bash)"'
        echo ""
        echo "#### Optional aliases you may wish to uncomment:"
        echo "#### If you want to quickly access a sub-project you can do that too:"
        echo "#### For example, instead of running this long command:"
        echo "####   make -C ~/git/vendor/enigmacurry/d.rymcg.tech/traefik config"
        echo "#### Now you can run just: traefik config"
        echo "#### You can do this for any sub-project name:"
        echo "# __d.rymcg.tech_project_alias traefik"
        echo ""
        echo "#### If you have external projects, you can create an alias for those too:"
        echo "#### Also add the full path to the external project:"
        echo "#### For example, external project 'foo' in the directory ~/git/foo"
        echo "# __d.rymcg.tech_project_alias foo ~/git/foo"
        echo ""
        echo "#### If you want a shorter alias than d.rymcg.tech (eg. 'dry') you can add it:"
        echo "# __d.rymcg.tech_cli_alias dry"
        echo ""
        echo "#### Create the 'foo' shell container alias:"
        echo "## See https://github.com/EnigmaCurry/d.rymcg.tech/blob/master/SHELL_CONTAINER.md"
        echo "# __d.rymcg.tech_shell_alias foo"
        echo ""
    else
        if [[ "${1}" == "bash" ]]; then
            declare -f __d.rymcg.tech_documentation_words
            declare -f __d.rymcg.tech_completions
            declare -f __d.rymcg.tech_shell_words
            declare -f __d.rymcg.tech_shell_completions
            declare -f __d.rymcg.tech_shell_alias
            declare -f __d.rymcg.tech_project_alias
            declare -f __d.rymcg.tech_cli_alias
            echo "complete -F __d.rymcg.tech_completions d.rymcg.tech"
        else
            fault "Sorry, this script only support BASH shell completion"
        fi
    fi
}

__d.rymcg.tech_shell_words() {
    echo "--clean --config --build --start --restart --stop --rm --destroy --attach --status --ls --sync --dev-sync --help --web --web-start --web-stop --web-open --open"
}

__shell() {
    if [[ "$#" == 0 || "$1" == "--help" ]]; then
        (
        echo "## Create containerized pet workstation environments, preconfigured for Docker devlopment:"
        echo -e "shell [--help]\tShow this help screen."
        echo -e "shell [INSTANCE] [TTY] [--args]\tKeyword arguments may be any of the following:"
        echo -e "$(__d.rymcg.tech_shell_words | fold -s | sed 's/^/\t/')]"
        echo -e "(The INSTANCE correlates with the shared volume name, and the TTY correlates with a particular running container name. The default INSTANCE is \`default\`, and the default TTY is \`1\`. Create a per-INSTANCE shell alias, as shown below, and then you only need to [optionally] specify TTY.)" | fold -s
        ) | sed 's/ $//' | expand -t 40
        __shell_alias_help
    else
        INSTANCE="default"; TTY="1"; targets="";
        arg_position=0
        for arg in "$@"; do
            if [[ "${arg}" =~ ^-.* ]]; then
                ## Parse keyword arguments:
                case "${arg}" in
                    --help | -help) __shell_alias_help; exit;;
                    --clean | -clean) targets="${targets} clean";;
                    --config | -config) targets="${targets} config";;
                    --build | -build) targets="${targets} build";;
                    --start | -start) targets="${targets} start";;
                    --restart | -restart) targets="${targets} restart";;
                    --stop | -stop) targets="${targets} stop";;
                    --rm | -rm) targets="${targets} stop";;
                    --destroy | -destroy) targets="${targets} destroy";;
                    --attach | -attach) targets="${targets} attach";;
                    --status | -status) targets="${targets} status";;
                    --ls | -ls) targets="${targets} status";;
                    --sync | -sync) targets="${targets} sync";;
                    --dev-sync | -dev-sync) targets="${targets} dev-sync";;
                    --web | -web) targets="${targets} web-start";;
                    --web-start | -web-start) targets="${targets} web-start";;
                    --web-stop | -web-stop) targets="${targets} web-stop";;
                    --web-open | -web-open) targets="${targets} open";;
                    --open | -open) targets="${targets} open";;
                    *) fault "Bad argument: ${arg}"
                esac
            else
                ## Parse positional arguments:
                arg_position="$((arg_position + 1))"
                case "${arg_position}" in
                    1) INSTANCE="${arg}";;
                    2) TTY="${arg}";;
                    *) fault "Too many positional arguments."
                esac
            fi
        done
        if [[ -z "${targets}" ]]; then
            targets="attach"
        fi
        (set -x; make --no-print-directory -C "${SHELL_CONTAINER_ROOT}" ${targets} "INSTANCE=${INSTANCE}" "TTY=${TTY}")
    fi
}

__shell_alias_help() {
    # Get the name of the alias used from the full command: shell foo --help
    local instance=$(echo ${FULL_COMMAND_ARGS} | cut -d " " -f 2 | grep -v '^-' | sed 's/ //g')
    test -z "${instance}" && instance=foo
    (
        echo -e ""
        echo -e "## Create a Bash alias for each of your shell container instances (eg. \`${instance}\`):"
        echo -e "__d.rymcg.tech_shell_alias ${instance}"
        echo -e ""
        echo -e "## Then use the \`${instance}\` instance alias like this:"
        echo -e "## ${instance} [TTY] --args ..."
        echo -e ""
        echo -e "${instance}\tConfigure, Build, Start, and Attach to the \`nix-${instance}-1\` container on TTY '1'."
        echo -e "${instance} 2\tConfigure, Build, Start, and Attach to the \`nix-${instance}-2\` container on TTY '2'."
        echo -e "\t(If already configured, built, and started, it will attach to the already running container.)"
        echo -e "${instance} --help\tShow this help message."
        echo -e "${instance} --config\tCreate/Edit the ${instance} instance \`.env_{DOCKER_CONTEXT}_${instance}\` config file."
        echo -e "\t(The .env file is saved to ${ROOT_DIR}/_terminal/nix)"
        echo -e "${instance} --clean\tDelete the \`.env_{DOCKER_CONTEXT}_${instance}\` config file for the instance ${instance}."
        echo -e "${instance} --build\tBuild the container images for the ${instance} instance."
        echo -e "${instance} --start\tStart the \`nix-${instance}-1\` instance container in the background on TTY '1'."
        echo -e "${instance} --stop\tStop the container of the ${instance} instance on TTY '1'."
        echo -e "${instance} --restart\tStop and Restart the ${instance} instance container in the background on TTY '1'."
        echo -e "${instance} --destroy\tDestroy ALL of the ${instance} instance containers and the home directory volume."
        echo -e "${instance} --status\tShow all of the running ${instance} instance TTY containers."
        echo -e "${instance} --sync\tSynchronize the local nixpkgs config to the ${instance} instance volume."
        echo -e "${instance} --dev-sync\tContinuously synchronize the local nixpkgs config to the ${instance} instance volume."
        echo -e "${instance} bar --start\tStart the \`nix-${instance}-bar\` instance container in the background on TTY 'bar'."
        echo -e "${instance} bar --stop\tStop the \`nix-${instance}-bar\` instance container on TTY 'bar'."
        echo -e "${instance} bar --restart\tStop and Restart the \`nix-${instance}-bar\` instance container in the background on TTY 'bar'."
    ) | expand -t 30
}

main() {
    if [[ $# -gt 0 ]]; then
        COMMAND=$1; shift
        case ${COMMAND} in
            help)
                __help "$@";;
            create)
                __create "$@";;
            cd)
                __change-directory "$@";;
            make)
                __make "$@";;
            list)
                __list_projects "$@";;
            readme)
                __readme "$@";;
            completion)
                __completion "$@";;
            info)
                __info "$@";;
            context)
                __context "$@";;
            script)
                __run_script "$@";;
            shell)
                __shell "$@";;
            *)
                fault "Invalid command"
        esac
    else
        __help
    fi
}

main "$@"
