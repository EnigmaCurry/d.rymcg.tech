#!/bin/bash
## The eponymous CLI script for the project d.rymcg.tech

## This script should be symlinked to a directory on your PATH. You
## may add the `user` subdirectory to your path, which contains a
## symlink prepared for you. DO NOT add the whole _scripts directory
## to your PATH, but only the _scripts/user subdirectory! DO NOT move
## this script, only make symlinks to it!
##
## For example (choose one or the other):
##
##   # Option 1 - This assumes ~/bin is already in your PATH:
##   ln -s ~/git/vendor/enigmacurry/d.rymcg.tech/_scripts/d.rymcg.tech ~/bin
##
##   # Option 2 - You would add this to the botom of your ~/.bashrc or ~/.profile
##   export PATH=~/git/vendor/enigmacurry/d.rymcg.tech/_scripts/user:${PATH}

set -eo pipefail

## BIN is the _scripts directory inside of d.rymcg.tech
BIN=$(dirname $(realpath ${BASH_SOURCE}))

## INFO_WORDS are keys to information that the completion script can ask for at runtime:
INFO_WORDS="INFO_WORDS ROOT_DIR"

## ROOT_DIR is the root path of the d.rymcg.tech project
ROOT_DIR=$(dirname ${BIN})
(test -f ${BIN}/funcs.sh && test -f ${ROOT_DIR}/Makefile && test -d ${ROOT_DIR}/traefik) || \
    (echo "Error: Invalid or corrupted d.rymcg.tech ROOT_DIR: ${ROOT_DIR}" >/dev/stderr
     echo "This script will not function properly if it has been moved." >/dev/stderr
     exit 1)

source ${BIN}/funcs.sh

export D_RYMCG_TECH_SCRIPT=true

__help() {
    echo "Found ROOT_DIR=${ROOT_DIR}"
    echo ""
    echo "## Main d.rymcg.tech sub-commands - Optional arguments are printed in brackets [OPTIONAL_ARG]"
    (
        echo -e "cd [SUBDIR]\tEnter a sub-shell and go to the ROOT_DIR directory (or given subdirectory)"
        echo -e "make [PROJECT] [ARGS ...]\tRun a \`make\` command for the given d.rymcg.tech project name"
        echo -e "context\tView or set the current Docker context"
        echo -e "new-context\tCreate a new Docker context"
        echo -e "tmp-context\tUse a temporary Docker context in a sub-shell"
        echo -e "aliases\tPrint help to setup Bash aliases"
        echo -e "config\tConfigure the current Docker context"
        echo -e "ssh [COMMAND ...]\tRun command or shell on active docker context SSH host"
        echo -e "completion\tSetup TAB completion in your shell"
        echo -e "install\tInstall an app interactively"
        echo -e "install-docker\tInstall Docker Engine on the host"
        echo -e "status\tShow status of all installed services"
        echo -e "audit\tPrint security audit of running containers"
        echo -e "script\tRun a script provided by the d.rymcg.tech _scripts directory"
        echo -e "sshd-config [Var=value ...]\tReconfigure the host SSH daemon of the remote context"
        echo -e "ssh-expose PORT\tExpose a workstation's port to a public server port"
        echo -e "s3-volume\tCreate an Rclone S3 backed volume"
        echo -e "docker-default-address-pool\tReconfigure the docker daemon network address pool"
        echo -e "show-ports\tShow the list of open ports and host bound containers"
        echo -e "route\tConfigure and/or print routes"
        echo -e "networks\tPrint the list of Docker networks"
        echo -e "fail2ban\tConfigure fail2ban on the Docker host"
        echo -e "reconfigure\tReconfigure a single env var in the root context config"
        echo -e "dotenv_get\tRetrieve a single env var from the root context config"
        echo -e "daemon-conf\tReconfigures the Docker host's daemon config"
        echo -e "image-catalog [ARGS ...]\tCatalog all Docker images across projects"
        echo -e "image-build [ARGS ...]\tBuild/pull all Docker images"
        echo -e "image-archive [ARGS ...]\tArchive Docker images to local .tar.gz files"
        echo -e "image-restore [ARGS ...]\tRestore archived Docker images to the server"
        echo -e "export-env\tExport all .env files for current context as flat env vars"
        echo -e "restore-env [FILE]\tRestore .env files from flat env var input (file or stdin)"
        echo -e "agent\tRun agent readiness tool"
        echo -e "workstation-usb-image\tBuild NixOS disk image for USB"
        echo -e "workstation-usb-install DEV\tInstall NixOS workstation to USB"
        echo -e "workstation-usb-clone DEV\tClone booted workstation USB to another device"
        echo -e "workstation-usb-post-install DIR\tCopy archive data to USB"
        echo -e "workstation-usb-download-isos\tDownload Debian + Fedora ISOs"
        echo -e "workstation-usb-download-docker-packages\tDownload Docker CE packages"
        echo -e "droplet [--tag TAG] [--preset PRESET --name NAME] [--create-preset PRESET]\tManage DigitalOcean droplets (alias: gumdrop)"
    ) | expand -t 30
    echo ""
    echo "## Documentation sub-commands:"
    (
        echo -e "help\tShow this help screen"
        echo -e "list\tList available d.rymcg.tech projects"
        echo -e "\t(not including external projects, unless you symlink them into ROOT_DIR)"
        echo -e "readme\tOpen the main d.rymcg.tech README.md in your browser"
        echo -e "readme [PROJECT]\tOpen the README.md for the given project name"
        while IFS=' ' read -ra DOC_WORDS; do
            for word in "${DOC_WORDS[@]}"; do
                FILE_EXTENSION="md"
                test "${word}" == "license" && FILE_EXTENSION="txt"
                echo -e "readme ${word}\tOpen root documentation file: $(echo ${word} | tr '[:lower:]' '[:upper:']).${FILE_EXTENSION}"
            done
        done <<< "$(__d.rymcg.tech_documentation_words --lowercase | sed 's/readme//')"
        #echo -e "info\tInternal read-only information for shell completion support"
    ) | expand -t 30
    echo ""
}

__install_docker() {
    local target method
    target=$(wizard choose "Where do you want to install Docker?" "Remote (Docker context host)" "Local (this machine)")
    if [[ "$target" == "Local"* ]]; then
        method=$(wizard choose "How do you want to install?" "Download from the internet (get.docker.com)" "Install from offline package archive")
        if [[ "$method" == "Download"* ]]; then
            confirm yes "This will install Docker on the local machine"
            if ! curl -fsSL https://get.docker.com | sh; then
                echo ""
                echo "Download failed. Try again with the offline package archive option."
                return 1
            fi
        else
            __install_docker_offline local
        fi
    else
        method=$(wizard choose "How do you want to install?" "Download from the internet (get.docker.com)" "Install from offline package archive")
        if [[ "$method" == "Download"* ]]; then
            confirm yes "This will install Docker on the host of your remote Docker context."
            if ! d.rymcg.tech ssh 'curl -fsSL https://get.docker.com | sh'; then
                echo ""
                echo "Download failed. Try again with the offline package archive option."
                return 1
            fi
            d.rymcg.tech ssh 'systemctl enable --now docker'
            d.rymcg.tech ssh 'systemctl status docker'
        else
            __install_docker_offline remote
        fi
    fi
}

__install_docker_offline() {
    local target="$1"
    local pkg_dir="${ROOT_DIR}/_archive/docker-packages"
    local distro id

    if [[ "$target" == "local" ]]; then
        id=$(. /etc/os-release 2>/dev/null && echo "$ID")
    else
        id=$(d.rymcg.tech ssh 'source /etc/os-release 2>/dev/null && echo "$ID"')
    fi
    case "$id" in
        debian|ubuntu|raspbian) distro="debian" ;;
        fedora|centos|rhel|rocky|alma) distro="fedora" ;;
        *) fault "Unsupported distro for offline Docker install: $id" ;;
    esac

    local src_dir="$pkg_dir/$distro"
    if [[ ! -d "$src_dir" ]] || [[ -z "$(ls -A "$src_dir" 2>/dev/null)" ]]; then
        fault "No $distro packages found in $src_dir — run: d.rymcg.tech workstation-usb-download-docker-packages"
    fi

    if [[ "$target" == "local" ]]; then
        confirm yes "This will install Docker offline on the local machine from $src_dir"
        echo "Installing Docker from offline $distro packages..."
        if [[ "$distro" == "debian" ]]; then
            sudo dpkg -i "$src_dir"/*.deb
        else
            sudo dnf install -y "$src_dir"/*.rpm
        fi
        sudo systemctl enable --now docker
        sudo systemctl status docker
    else
        confirm yes "This will install Docker offline on the host of your remote Docker context."
        echo "Copying $distro packages to remote host..."
        local remote_dir="/tmp/docker-packages"
        d.rymcg.tech ssh "mkdir -p $remote_dir"
        local docker_host
        docker_host=$(docker context inspect --format '{{.Endpoints.docker.Host}}')
        local ssh_dest="${docker_host#ssh://}"
        scp "$src_dir"/* "$ssh_dest:$remote_dir/"
        echo "Installing Docker from offline packages..."
        if [[ "$distro" == "debian" ]]; then
            d.rymcg.tech ssh "dpkg -i $remote_dir/*.deb"
        else
            d.rymcg.tech ssh "dnf install -y $remote_dir/*.rpm"
        fi
        d.rymcg.tech ssh "rm -rf $remote_dir"
        d.rymcg.tech ssh 'systemctl enable --now docker'
        d.rymcg.tech ssh 'systemctl status docker'
    fi
}

__install() {
    if [[ $# -gt 0 ]]; then
        fault "install does not take any args"
    fi
    make --no-print-directory -C ${ROOT_DIR} install
}

__change-directory() {
    if [[ $# -gt 0 ]]; then
        __make $1 cd
    else
        __make -- cd
    fi
    echo "Exited sub-shell."
}

__make() {
    if [[ $# -gt 0 ]]; then
        PROJECT_NAME="$1"; shift
        pattern="^-+$"
        if [[ "${PROJECT_NAME}" =~ $pattern ]]; then
            PROJECT_DIR=${ROOT_DIR}
        else
            PROJECT_DIR=${ROOT_DIR}/${PROJECT_NAME}
        fi
        test -d "${PROJECT_DIR}" || fault "Project directory does not exist: ${PROJECT_DIR}"
        make --no-print-directory -C "${PROJECT_DIR}" "$@" D_RYMCG_TECH_CLI_ALIAS=${D_RYMCG_TECH_CLI_ALIAS}
    else
        __list_projects
        error "Missing project name argument. Choose one from the above."
        error "To invoke the root Makefile use '-' as the name"
    fi
    DIR_NAME="$1"; shift
}

__list_projects() {
    (
        if [[ "$1" == "--raw" ]]; then
            find -L "${ROOT_DIR}" -maxdepth 1 -type d -printf "%P\n" | grep -v "^_" | grep -v "^\." | sort -u | xargs -iXX /bin/bash -c "test -f ${ROOT_DIR}/XX/Makefile && echo XX"
        else
            echo "List of available d.rymcg.tech projects (not including external projects):"
            echo ""
            set +e
            declare -A descriptions
            while IFS=$'\t' read -r dirname desc; do
                descriptions["$dirname"]="$desc"
            done < <(awk '
                function output() {
                    if (dirname != "") {
                        sub(/\.$/, "", desc)
                        print dirname "\t" desc
                    }
                    dirname = ""; desc = ""; state = 0
                }
                /^\* \[/ {
                    output()
                    if (match($0, /^\* \[[^\]]*\]\(([^#)]*)[^)]*\)(.*)/, m)) {
                        dirname = m[1]; rest = m[2]
                        if (match(rest, /^ *- *(.+)/, d)) {
                            desc = d[1]; state = 1
                        } else { state = 2 }
                    }
                    next
                }
                state == 1 && /^[[:space:]]/ && !/^  \* / {
                    sub(/^[[:space:]]+/, " "); desc = desc $0; next
                }
                state == 2 && /^  \* / {
                    sub(/^  \* /, ""); desc = $0; state = 3; next
                }
                state == 3 && /^[[:space:]]/ && !/^  \* / {
                    sub(/^[[:space:]]+/, " "); desc = desc $0; next
                }
                { state = 0 }
                END { output() }
            ' "${ROOT_DIR}/README.md")
            while read -r project; do
                printf '%s\t%s\n' "$project" "${descriptions[$project]:-}"
            done < <(get_all_projects) | column -t -s $'\t'
            echo ""
        fi
    )
}

__readme() {
    if [[ $# -gt 0 ]]; then
        NAME="${1}"; shift
        NAME_UPPERCASE="$(echo "${NAME}" | tr '[:lower:]' '[:upper:]')"
        IFS=" " read -ra DOCS_ARRAY <<< "$(__d.rymcg.tech_documentation_words --uppercase)"
        declare -A DOCS_INDEX
        for doc in "${DOCS_ARRAY[@]}"; do
            DOCS_INDEX["${doc}"]="${doc}"
        done
        if [[ "${NAME_UPPERCASE}" == "LICENSE" ]]; then
            exe xdg-open "https://github.com/EnigmaCurry/d.rymcg.tech/blob/master/LICENSE.txt"
        elif [[ -v DOCS_INDEX["${NAME_UPPERCASE}"] ]]; then
            exe xdg-open "https://github.com/EnigmaCurry/d.rymcg.tech/blob/master/${NAME_UPPERCASE}.md#readme"
        else
            echo ${DOCS_INDEX["${NAME_UPPERCASE}"]}
            __make "${NAME}" readme "$@"
        fi
    else
        __make -- readme
    fi
}

__info() {
    if [[ $# == 0 ]]; then
        echo "## info returns read-only information about your d.rymcg.tech installation."
        echo "## This is an undocumented internal command for the completion scripts private use."
        echo "## Its behaviour is subject to change without notice."
        echo ""
        echo "## Available info keys:"
        IFS=" " read -ra WORDS <<< "${INFO_WORDS}"
        for word in "${WORDS[@]}"; do
            echo "${word}"
        done
        echo ""
    elif [[ "$1" == "ROOT_DIR" ]]; then
        echo "${ROOT_DIR}"
    elif [[ "$1" == "INFO_WORDS" ]]; then
        echo "${INFO_WORDS}"
    fi
}

__context() {
    if [[ $# == 0 ]]; then
        test -n "${DOCKER_CONTEXT}" && echo -e "DOCKER_CONTEXT=${DOCKER_CONTEXT}\nThe Docker context cannot be switched because the DOCKER_CONTEXT env var is currently set, and this would override your selection.\n\nYou may use \`d tmp-context\` instead, or try exiting the shell you are in, or unset DOCKER_CONTEXT, and try again. " && fault
        ${BIN}/install_script-wizard
        echo
        readarray -t CONTEXTS < <(docker context list -q | grep -v default)
        local CURRENT_CONTEXT=$(docker context show)
        local CHOSEN_CONTEXT=$(wizard choose "Select the Docker context to use" "${CONTEXTS[@]}" --default "${CURRENT_CONTEXT}")
        docker context use "${CHOSEN_CONTEXT}"
    elif [[ "$1" == "new" ]]; then
        __new_context
    elif [[ "$1" == "tmp" ]]; then
        __context_tmp
    else
        exe docker context "$@"
    fi
}

__context_tmp() {
    readarray -t CONTEXTS < <(docker context list -q | grep -v default)
    local CURRENT_CONTEXT=$(docker context show)
    local CHOSEN_CONTEXT="$1";
    if [[ -z "${CHOSEN_CONTEXT}" ]]; then
        CHOSEN_CONTEXT=$(wizard choose "Choose a temporary docker context" "${CONTEXTS[@]}" --default "${CURRENT_CONTEXT}")
    else
        shift;
    fi

    test -z "$CHOSEN_CONTEXT" && fault "No context selected."
    if ! element_in_array "$CHOSEN_CONTEXT" "${CONTEXTS[@]}"; then
        fault "Context ${CHOSEN_CONTEXT} does not exist.";
    fi
    if [[ $# == 0 ]]; then
        echo "Entering sub-shell DOCKER_CONTEXT=${CHOSEN_CONTEXT}"
        bash --rcfile <(echo "export DOCKER_CONTEXT=${CHOSEN_CONTEXT}; source ~/.bashrc; unset MAKEFLAGS PROMPT_COMMAND D_RYMCG_TECH_CLI_ALIAS D_RYMCG_TECH_CONTEXT_ALIAS D_RYMCG_TECH_PROJECT_ALIAS D_RYMCG_TECH_SCRIPT; PS1=\"[@:\$DOCKER_CONTEXT] \${PS1}\"") -i
    else
        echo "+ DOCKER_CONTEXT=${CHOSEN_CONTEXT}" >/dev/stderr
        if [[ "$1" == "d" ]]; then
            shift
            DOCKER_CONTEXT="${CHOSEN_CONTEXT}" exe d.rymcg.tech $@
        else
            DOCKER_CONTEXT="${CHOSEN_CONTEXT}" exe $@
        fi
    fi
}

__new_context() {
        echo
        confirm yes "This command can help create a new SSH config and Docker context"
        echo
        CHOICE=$(wizard choose --numeric "You must specify the SSH config entry to use" "I want to make a new SSH host entry in ~/.ssh/config" "I want to use an existing SSH host entry in ~/.ssh/config")
        if [[ "${CHOICE}" == 0 ]]; then
            SSH_HOST=$(wizard ask "Enter the new SSH context name (short host name) :")
            if grep "^Host ${SSH_HOST}$" ~/.ssh/config  >/dev/null 2>&1; then
                error "There is already an SSH config named ${SSH_HOST}."
                fault "You must edit ~/.ssh/config by hand and remove the Host entry named ${SSH_HOST}."
            fi
            SSH_HOSTNAME=$(wizard ask "Enter the fully qualified SSH Host DNS name or IP address :")
            TMP_CONFIG=$(mktemp)
            check_var SSH_HOST SSH_HOSTNAME
            [[ "$SSH_HOST" == "default" ]] && \
                fault "SSH host must not be named default."
            cat <<EOF > ${TMP_CONFIG}
Host ${SSH_HOST}
     Hostname ${SSH_HOSTNAME}
     User root
     ControlMaster auto
     ControlPersist yes
     ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
            echo "## Here is the new SSH config entry:"
            cat ${TMP_CONFIG}
            echo
            confirm "no" "Do you want to append this config to ~/.ssh/config" "?"
            (echo; cat ${TMP_CONFIG}; echo) >> ~/.ssh/config
            rm -f ${TMP_CONFIG}
        elif [[ "${CHOICE}" == 1 ]]; then
            SSH_HOST=$(choose "Choose an existing SSH Host config" $(cat ~/.ssh/config | grep -Po "^Host \K.*"))
        else
            fault invalid choice
        fi
        check_var SSH_HOST
        if docker context inspect ${SSH_HOST} >/dev/null 2>&1; then
            echo
            error "There is already a Docker context named ${SSH_HOST}"
            confirm no "Do you want to remove and recreate this context" "?"
            docker context rm -f ${SSH_HOST}
        fi
        docker context create "${SSH_HOST}" --description "Created by 'd.rymcg.tech context new'" --docker "host=ssh://${SSH_HOST}"
        echo
        echo "## Here are all your configured Docker contexts:"
        docker context ls
        echo ""
        confirm "no" "Do you want to switch to the new ${SSH_HOST} context now" "?"
        docker context use ${SSH_HOST}
}

__run_script() {
    CMD="${1:-}"
    shift || true
    if [[ -z "$CMD" ]]; then
        find "${ROOT_DIR}/_scripts" -maxdepth 1 -type f -perm -u+x -printf '%f\n'
        echo
        echo "## \`d.rymcg.tech script\` runs any script by name (${ROOT_DIR}/_scripts)"
        echo
        exit 1
    else
        "${ROOT_DIR}/_scripts/${CMD}" "$@"
    fi
}

__d.rymcg.tech_cli_alias() {
    local ALIAS="$1"
    alias $1="D_RYMCG_TECH_CLI_ALIAS=${ALIAS} d.rymcg.tech "
    complete -F __d.rymcg.tech_completions $1

}

__d.rymcg.tech_project_alias() {
    local ROOT_DIR=$(d.rymcg.tech info ROOT_DIR)
    __ALIAS="${1}"
    __PROJECT_DIR="${2}"
    test -z "${__PROJECT_DIR}" && __PROJECT_DIR="${ROOT_DIR}/${__ALIAS}"
    export __ALIAS __PROJECT_DIR
    alias $1="make --no-print-directory -C ${__PROJECT_DIR} D_RYMCG_TECH_PROJECT_ALIAS=${__ALIAS}"
    read -r -d '' FUNC <<'EOF'
function _${__ALIAS}_complete {
    local __PROJECT_DIR=${__PROJECT_DIR}
    MAKE_TARGETS="$(make -C "${__PROJECT_DIR}" -qp 2>/dev/null | awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ {split($1,A,/ /);for(i in A)print A[i]}' | grep -v "^Makefile$" | sort -u)"
    if [[ ${COMP_CWORD} == 1 ]]; then
        COMPREPLY=($(compgen -W "${MAKE_TARGETS}" "${COMP_WORDS[1]}"))
    else
        COMPREPLY=()
    fi
}
EOF
    FUNC=$(echo "${FUNC}" | envsubst '${__ALIAS} ${__PROJECT_DIR}')
    eval "${FUNC}"
    complete -o filenames -F _${__ALIAS}_complete ${__ALIAS}
    unset __ALIAS __PROJECT_DIR
}

__d.rymcg.tech_context_alias() {
    local ROOT_DIR=$(d.rymcg.tech info ROOT_DIR)
    __CONTEXT="${1}"
    __ALIAS="${2:-${1}}"
    export __CONTEXT
    alias ${__ALIAS}="D_RYMCG_TECH_CONTEXT_ALIAS=${__ALIAS} d.rymcg.tech tmp-context ${__CONTEXT} d.rymcg.tech"
    complete -F __d.rymcg.tech_completions ${__ALIAS}
}

__d.rymcg.tech_completions() {
    ### BASH completion
    ## dev links:
    ### https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins
    ### https://iridakos.com/programming/2018/03/01/bash-programmable-completion-tutorial
    ### https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
    ## COMP_WORDS: an array of all the words typed
    ## COMP_CWORD: an index of the COMP_WORDS array pointing to the word the current cursor is at
    ## COMP_LINE: the current command line
    ## COMPREPLY is an array variable used to store the output completions
    ROOT_PROJECT_PLACEHOLDER="^-+$"
    INFO_WORDS=$(d.rymcg.tech info INFO_WORDS)
    ROOT_DIR=$(d.rymcg.tech info ROOT_DIR)

    if [[ ${COMP_CWORD} == 1 ]]; then
        ## Complete the main command:
        ## d.rymcg.tech <TAB> ...
        COMMANDS="help create cd make list readme info context new-context tmp-context aliases completion install install-docker status ssh audit sshd-config ssh-expose show-ports s3-volume docker-default-address-pool route routes reconfigure dotenv_get daemon-conf fail2ban networks config image-catalog image-build image-archive image-restore agent workstation-usb-image workstation-usb-install workstation-usb-clone workstation-usb-post-install workstation-usb-download-isos workstation-usb-download-docker-packages workstation-usb-test-vm droplet gumdrop"
        COMPREPLY=($(compgen -W "${COMMANDS}" "${COMP_WORDS[1]}"))
    elif [[ ${COMP_CWORD} == 2 ]]; then
        ALL_PROJECTS=$(d.rymcg.tech list --raw)
        ## Dispatch completion for the sub-command's first argument:
        ## d.rymcg.tech make <TAB> ...
        case ${COMP_WORDS[1]} in
            create)
                COMPREPLY=("#" "Type the project name");;
            cd)
                COMPREPLY=($(compgen -W "${ALL_PROJECTS}" "${COMP_WORDS[2]}"));;
            readme)
                COMPREPLY=($(compgen -W "$(__d.rymcg.tech_documentation_words) ${ALL_PROJECTS}" "${COMP_WORDS[2]}"));;
            make)
                COMPREPLY=($(compgen -W "-- ${ALL_PROJECTS}" "${COMP_WORDS[2]}"));;
            context)
                COMPREPLY=($(compgen -W "$(docker context ls --format '{{.Name}}')" "${COMP_WORDS[2]}"));;
            info)
                COMPREPLY=($(compgen -W "${INFO_WORDS}" "${COMP_WORDS[2]}"));;
            script)
                COMPREPLY=($(compgen -W "$(find ${ROOT_DIR}/_scripts -executable -printf '%P\n' | grep -v d.rymcg.tech)" "${COMP_WORDS[2]}"));;
        esac
    elif [[ ${COMP_CWORD} == 3 ]]; then
        ## Dispatch completion for the sub-commands second argument:
        ## d.rymcg.tech make traefik <TAB> ...
        if [[ "${COMP_WORDS[1]}" == "make" ]]; then
            PROJECT=${COMP_WORDS[2]}
            PROJECT_DIR="${ROOT_DIR}/${PROJECT}"
            if [[ "${PROJECT}" =~ ${ROOT_PROJECT_PLACEHOLDER} ]]; then
                PROJECT_DIR="${ROOT_DIR}"
            fi
            ## Thanks Chris Down https://unix.stackexchange.com/a/230050
            MAKE_TARGETS="$(make -C "${PROJECT_DIR}" -qp 2>/dev/null | awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ {split($1,A,/ /);for(i in A)print A[i]}' | sort -u)"
            COMPREPLY=($(compgen -W "${MAKE_TARGETS}" "${COMP_WORDS[3]}"))
        elif [[ "${COMP_WORDS[1]}" == "create" ]]; then
            COMPREPLY=($(compgen -W "$(find ${ROOT_DIR}/_templates -maxdepth 1 -type d -printf "%P\n" | grep -v "^_")" "${COMP_WORDS[3]}"))
        fi
    fi
}


__d.rymcg.tech_documentation_words() {
    ROOT_DIR=$(d.rymcg.tech info ROOT_DIR)
    ## Find list of available documentation files
    declare -A DOCS_INDEX
    local doc_files=""
    if git -C "${ROOT_DIR}" rev-parse --git-dir &>/dev/null; then
        doc_files=$(git -C "${ROOT_DIR}" ls-tree --name-only origin/master 2>/dev/null | \
                       grep -E "(\.txt$|\.md$)" | \
                       sed -e 's/\.txt$//' -e 's/\.md$//')
    else
        # Not a git repo (e.g. read-only nix store copy): find files directly
        doc_files=$(find "${ROOT_DIR}" -maxdepth 1 -name '*.md' -o -name '*.txt' 2>/dev/null | \
                       xargs -I{} basename {} | \
                       sed -e 's/\.txt$//' -e 's/\.md$//')
    fi
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        DOCS_INDEX["$line"]="$line"
    done <<< "$doc_files"
    if [[ "$1" == "--lowercase" ]]; then
        echo "$(echo ${DOCS_INDEX[@]} | tr '[:upper:]' '[:lower:]')"
    elif [[ "$1" == "--uppercase" ]]; then
        echo "$(echo ${DOCS_INDEX[@]} | tr '[:lower:]' '[:upper:]')"
    else
        echo "$(echo ${DOCS_INDEX[@]} | tr '[:lower:]' '[:upper:]') $(echo ${DOCS_INDEX[@]} | tr '[:upper:]' '[:lower:]')"
    fi
}

__completion() {
    # Print the completion script to be evaluated
    USER_SCRIPT_PATH=$(echo "${ROOT_DIR}/_scripts/user" | sed "s|${HOME}|\$\{HOME\}|")
    if [[ $# -lt 1 ]]; then
        echo "#### To enable BASH shell completion support for d.rymcg.tech,"
        echo "#### add the following lines into your ~/.bashrc ::"
        echo "export PATH=\${PATH}:${USER_SCRIPT_PATH}"
        echo 'eval "$(d.rymcg.tech completion bash)"'
        echo ""
        echo "#### Optional aliases you may wish to uncomment:"
        echo "#### If you want to quickly access a sub-project you can do that too:"
        echo "#### For example, instead of running this long command:"
        echo "####   make -C ~/git/vendor/enigmacurry/d.rymcg.tech/traefik config"
        echo "#### Now you can run just: traefik config"
        echo "#### You can do this for any sub-project name:"
        echo "# __d.rymcg.tech_project_alias traefik"
        echo ""
        echo "#### If you have external projects, you can create an alias for those too:"
        echo "#### Also add the full path to the external project:"
        echo "#### For example, external project 'foo' in the directory ~/git/foo"
        echo "# __d.rymcg.tech_project_alias foo ~/git/foo"
        echo ""
        echo "#### If you want to quickly access a particular Docker context (eg. 'sentry'):"
        echo "#### For example, instead of running this long command:"
        echo "####   d tmp-context sentry d make traefik config"
        echo "#### Now you can run just: sentry make traefik config"
        echo "#### You can do this for any Docker context:"
        echo "# __d.rymcg.tech_context_alias sentry"
        echo ""
        echo "#### If you want a shorter alias than d.rymcg.tech (eg. 'd') you can add it:"
        echo "# __d.rymcg.tech_cli_alias d"
        echo ""
    else
        if [[ "${1}" == "bash" ]]; then
            declare -f __d.rymcg.tech_documentation_words
            declare -f __d.rymcg.tech_completions
            declare -f __d.rymcg.tech_project_alias
            declare -f __d.rymcg.tech_context_alias
            declare -f __d.rymcg.tech_cli_alias
            echo "complete -F __d.rymcg.tech_completions d.rymcg.tech"
        else
            fault "Sorry, this script only support BASH shell completion"
        fi
    fi
}

__export_env() {
    local DOCKER_CONTEXT=${DOCKER_CONTEXT:-$(${BIN}/docker_context)}
    local ctx="${DOCKER_CONTEXT}"
    cd "${ROOT_DIR}"

    # Root env file
    local root_env=".env_${ctx}"
    if [[ -f "${root_env}" ]]; then
        echo "## ${root_env}"
        ${BIN}/dotenv -f "${root_env}" parse
    fi

    # Project env files
    for env_file in */.env_${ctx}_*; do
        [[ -f "${env_file}" ]] || continue
        local project_dir="${env_file%%/*}"
        local basename="${env_file#*/}"
        # Strip .env_${ctx}_ prefix to get instance name
        local instance="${basename#.env_${ctx}_}"

        echo
        echo "## ${env_file}"
        if [[ "${instance}" == "default" ]]; then
            ${BIN}/dotenv -f "${env_file}" parse
        else
            while IFS= read -r line; do
                local key="${line%%=*}"
                local val="${line#*=}"
                echo "__${instance}__${key}=${val}"
            done < <(${BIN}/dotenv -f "${env_file}" parse)
        fi
    done
}

__restore_env() {
    local DOCKER_CONTEXT=${DOCKER_CONTEXT:-$(${BIN}/docker_context)}
    local ctx="${DOCKER_CONTEXT}"
    cd "${ROOT_DIR}"

    # Read input from file arg or stdin
    local input
    if [[ $# -gt 0 && -f "$1" ]]; then
        input=$(cat "$1")
    else
        input=$(cat)
    fi

    # Build prefix→project mapping
    declare -A prefix_to_dir
    for project_dir in */; do
        local project_name="${project_dir%/}"
        local env_dist_file="${project_dir}.env-dist"
        [[ -f "${env_dist_file}" ]] || continue
        local prefix
        prefix=$("${BIN}/parse-env-meta.sh" "${env_dist_file}" PREFIX 2>/dev/null) || continue
        [[ -n "${prefix}" ]] || continue
        prefix_to_dir["${prefix}"]="${project_name}"
    done

    # Get known root var names
    declare -A root_vars
    while IFS= read -r line; do
        root_vars["${line%%=*}"]=1
    done < <(${BIN}/dotenv -f .env-dist parse)

    # Track which files have been initialized with config-dist
    declare -A initialized

    # Parse input and distribute
    while IFS= read -r line; do
        [[ -z "${line}" || "${line}" == "#"* ]] && continue
        local key="${line%%=*}"
        local val="${line#*=}"

        # Instance-prefixed var: __<instance>__<PREFIX>_<VAR>
        if [[ "${key}" == __*__* ]]; then
            local stripped="${key#__}"
            local instance="${stripped%%__*}"
            local original_key="${stripped#*__}"
            for prefix in "${!prefix_to_dir[@]}"; do
                if [[ "${original_key}" == "${prefix}_"* ]]; then
                    local project_name="${prefix_to_dir[${prefix}]}"
                    local init_key="${project_name}:${instance}"
                    if [[ -z "${initialized[${init_key}]+set}" ]]; then
                        initialized["${init_key}"]=1
                        cp "${project_name}/.env-dist" "${project_name}/.env_${ctx}_${instance}"
                        ${BIN}/dotenv -f "${project_name}/.env_${ctx}_${instance}" set "${prefix}_INSTANCE=${instance}"
                    fi
                    ${BIN}/reconfigure "${project_name}/.env_${ctx}_${instance}" "${original_key}=${val}" >&2
                    break
                fi
            done
        # Root var
        elif [[ -n "${root_vars[${key}]+set}" ]]; then
            if [[ -z "${initialized[root]+set}" ]]; then
                initialized["root"]=1
                cp .env-dist ".env_${ctx}"
            fi
            ${BIN}/reconfigure ".env_${ctx}" "${key}=${val}" >&2
        # Default-instance project var
        else
            for prefix in "${!prefix_to_dir[@]}"; do
                if [[ "${key}" == "${prefix}_"* ]]; then
                    local project_name="${prefix_to_dir[${prefix}]}"
                    local init_key="${project_name}:default"
                    if [[ -z "${initialized[${init_key}]+set}" ]]; then
                        initialized["${init_key}"]=1
                        cp "${project_name}/.env-dist" "${project_name}/.env_${ctx}_default"
                    fi
                    ${BIN}/reconfigure "${project_name}/.env_${ctx}_default" "${key}=${val}" >&2
                    break
                fi
            done
        fi
    done <<< "${input}"
}

main() {
    if [[ $# -gt 0 ]]; then
        COMMAND=$1; shift
        case ${COMMAND} in
            help)
                __help "$@";;
            cd)
                __change-directory "$@";;
            make)
                __make "$@";;
            list)
                __list_projects "$@";;
            readme)
                __readme "$@";;
            completion)
                __completion "$@";;
            info)
                __info "$@";;
            install)
                __install "$@";;
            install-docker)
                __install_docker "$@";;
            context)
                __context "$@";;
            new-context)
                __new_context "$@";;
            tmp-context)
                __context_tmp "$@";;
            aliases)
                __run_script aliases;;
            script)
                __run_script "$@";;
            ssh)
                docker_ssh "$@";;
            status)
                __make -- status | sed "s|\./|${ROOT_DIR}/|g" | less -FSX;;
            audit)
                __make -- audit | less -FSX;;
            sshd-config)
                export DOCKER_CONTEXT=${DOCKER_CONTEXT:-$(${BIN}/docker_context)}
                __run_script reconfigure_sshd "${DOCKER_CONTEXT}" "$@";;
            ssh-expose)
                export DOCKER_CONTEXT=${DOCKER_CONTEXT:-$(${BIN}/docker_context)}
                __run_script ssh_expose "${DOCKER_CONTEXT}" $@;;
            docker-default-address-pool)
                export DOCKER_CONTEXT=${DOCKER_CONTEXT:-$(${BIN}/docker_context)}
                __run_script docker_default_address_pool "${DOCKER_CONTEXT}" "$@";;
            show-ports)
                d.rymcg.tech make - show-ports;;
            route)
                CMD=$(echo d.rymcg.tech make traefik route ARGS=\"$@\")
                eval ${CMD};;
            routes)
                d.rymcg.tech make traefik route ARGS="list";;
            reconfigure)
                d.rymcg.tech make - reconfigure $@;;
            dotenv_get)
                d.rymcg.tech make - dotenv_get $@;;
            daemon-conf)
                d.rymcg.tech make - daemon-conf;;
            fail2ban)
                d.rymcg.tech make - fail2ban;;
            s3-volume)
                d.rymcg.tech make - s3-volume;;
            networks)
                __make -- networks;;
            config)
                __make -- config;;
            image-catalog)
                ${BIN}/image-catalog "$@";;
            image-build)
                ${BIN}/image-build "$@";;
            image-archive)
                ${BIN}/image-archive "$@";;
            image-restore)
                ${BIN}/image-restore "$@";;
            workstation-usb-image)
                ${BIN}/workstation-usb-image "$@";;
            workstation-usb-install)
                ${BIN}/workstation-usb-install "$@";;
            workstation-usb-clone)
                ${BIN}/workstation-usb-clone "$@";;
            workstation-usb-post-install)
                ${BIN}/workstation-usb-post-install "$@";;
            workstation-usb-download-isos)
                ${BIN}/workstation-usb-download-isos "$@";;
            workstation-usb-download-docker-packages)
                ${BIN}/workstation-usb-download-docker-packages "$@";;
            workstation-usb-test-vm)
                ${BIN}/workstation-usb-test-vm "$@";;
            agent)
                # Auto-detect current Docker context for 'check' command
                if [[ $# -eq 0 ]]; then
                    # No args - show help
                    ${BIN}/agent.py
                elif [[ "$1" == "check" ]] && ! echo "$@" | grep -q -- "--context"; then
                    # 'check' without --context - inject current context
                    local ctx=$(docker context show 2>/dev/null)
                    if [[ -n "$ctx" && "$ctx" != "default" ]]; then
                        ${BIN}/agent.py check --context "$ctx" "${@:2}"
                    else
                        ${BIN}/agent.py "$@"
                    fi
                else
                    ${BIN}/agent.py "$@"
                fi;;
            export-env)
                __export_env "$@";;
            restore-env)
                __restore_env "$@";;
            droplet|gumdrop)
                ${BIN}/gumdrop "$@";;
            *)
                fault "Invalid command"
        esac
    else
        __help
    fi
}

main "$@"
