#!/bin/bash
## gumdrop - Generic DigitalOcean droplet manager
## Usage: gumdrop [--tag TAG]
## Can be sourced as a library or run directly.

if [[ -n "${_GUMDROP_SOURCED}" ]]; then return 0 2>/dev/null || true; fi
_GUMDROP_SOURCED=1

SCRIPT_DIR=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
ROOT_DIR=$(readlink -f "${SCRIPT_DIR}/..")
BIN=${ROOT_DIR}/_scripts
source ${BIN}/funcs.sh

set -eo pipefail

## Configuration (override via env vars before sourcing):
GUMDROP_TAG="${GUMDROP_TAG:-}"
GUMDROP_LABEL="${GUMDROP_LABEL:-Droplet}"
GUMDROP_DEFAULT_IMAGE="${GUMDROP_DEFAULT_IMAGE:-debian-13-x64}"
GUMDROP_DEFAULT_REGION="${GUMDROP_DEFAULT_REGION:-nyc3}"
GUMDROP_DEFAULT_SIZE="${GUMDROP_DEFAULT_SIZE:-s-2vcpu-4gb}"
GUMDROP_SSH_KEY_NAME="${GUMDROP_SSH_KEY_NAME:-gumdrop}"
## Space-separated list of image slugs to offer. Empty = fetch all public images from doctl.
GUMDROP_IMAGES="${GUMDROP_IMAGES:-}"

gumdrop_check_doctl() {
    command -v doctl >/dev/null || fault "doctl is not installed. See https://docs.digitalocean.com/reference/doctl/how-to/install/"
    if ! doctl account get >/dev/null 2>&1; then
        confirm yes "doctl is not authenticated. Login now" "?" || fault "doctl is not authenticated."
        local context_name
        ask "Enter a name for this account" context_name "default"
        doctl auth init --context "${context_name}"
        doctl auth switch --context "${context_name}"
    fi
}

gumdrop_list() {
    local tag_args=()
    [[ -n "${GUMDROP_TAG}" ]] && tag_args=(--tag-name "${GUMDROP_TAG}")
    local account_email=$(doctl account get --format Email --no-header 2>/dev/null)
    local account_team=$(doctl account get --format Team --no-header 2>/dev/null)
    local account_context=$(doctl auth list 2>/dev/null | grep -oP '^.+(?= \(current\))' || echo "default")
    echo ""
    printf "## %-9s %s\n" "Account:" "${account_context}"
    printf "## %-9s %s\n" "Team:" "${account_team:+[${account_team}] }${account_email}"
    local count=$(doctl compute droplet list "${tag_args[@]}" --format ID --no-header 2>/dev/null | wc -l)
    if [[ ${count} -gt 0 ]]; then
        ## Build reserved IP lookup (droplet_id -> IP):
        declare -A _RIP_MAP
        while read -r rip rid; do
            [[ -n "${rid}" && "${rid}" != "0" ]] && _RIP_MAP["${rid}"]="${rip}"
        done < <(doctl compute reserved-ip list --format IP,DropletID --no-header 2>/dev/null)
        ## Print droplet table with ReservedIP column:
        {
            echo "ID Name PublicIPv4 ReservedIPv4 Region Size Status"
            while read -r id name pub region size status; do
                echo "${id} ${name} ${pub} ${_RIP_MAP[${id}]:--} ${region} ${size} ${status}"
            done < <(doctl compute droplet list "${tag_args[@]}" --format ID,Name,PublicIPv4,Region,SizeSlug,Status --no-header)
        } | column -t
    else
        echo "No ${GUMDROP_LABEL,,}s found${GUMDROP_TAG:+ (tag: ${GUMDROP_TAG})}."
    fi
    echo ""
}

gumdrop_ssh() {
    local tag_args=()
    [[ -n "${GUMDROP_TAG}" ]] && tag_args=(--tag-name "${GUMDROP_TAG}")
    readarray -t NAMES < <(doctl compute droplet list "${tag_args[@]}" --format Name --no-header)
    if [[ ${#NAMES[@]} -eq 0 ]]; then
        echo "No ${GUMDROP_LABEL,,}s found."
        return
    fi
    local name
    if ! name=$(wizard choose "SSH into which ${GUMDROP_LABEL,,}?" "${NAMES[@]}" --default "${NAMES[0]}"); then return; fi
    doctl compute ssh "${name}"
}

gumdrop_destroy() {
    local tag_args=()
    [[ -n "${GUMDROP_TAG}" ]] && tag_args=(--tag-name "${GUMDROP_TAG}")
    readarray -t NAMES < <(doctl compute droplet list "${tag_args[@]}" --format Name --no-header)
    if [[ ${#NAMES[@]} -eq 0 ]]; then
        echo "No ${GUMDROP_LABEL,,}s found."
        return
    fi
    local name
    if ! name=$(wizard choose "Destroy which ${GUMDROP_LABEL,,}?" "${NAMES[@]}" --default "${NAMES[0]}"); then return; fi
    confirm no "Are you sure you want to destroy '${name}'" "?" || return
    doctl compute droplet delete "${name}" --force
    echo "${GUMDROP_LABEL} '${name}' destroyed."
}

gumdrop_ensure_ssh_key() {
    readarray -t SSH_KEY_IDS < <(doctl compute ssh-key list --format ID --no-header)
    if [[ ${#SSH_KEY_IDS[@]} -eq 0 ]]; then
        echo ""
        echo "No SSH keys found in your DigitalOcean account."
        confirm yes "Upload a local SSH public key now" "?" || return 1
        gumdrop_upload_ssh_key
    fi
}

gumdrop_upload_ssh_key() {
    local KEY_OPTIONS=()
    local KEY_SOURCES=()
    declare -A SEEN_KEYS

    if ssh-add -L &>/dev/null; then
        while IFS= read -r line; do
            local fingerprint=$(echo "${line}" | ssh-keygen -lf - 2>/dev/null | awk '{print $2}')
            if [[ -n "${fingerprint}" && -z "${SEEN_KEYS[${fingerprint}]}" ]]; then
                SEEN_KEYS[${fingerprint}]=1
                local keytype=$(echo "${line}" | awk '{print $1}')
                KEY_OPTIONS+=("agent: ${keytype} ${fingerprint}")
                KEY_SOURCES+=("agent:${line}")
            fi
        done < <(ssh-add -L)
    fi

    while IFS= read -r pubfile; do
        local fingerprint=$(ssh-keygen -lf "${pubfile}" 2>/dev/null | awk '{print $2}')
        if [[ -n "${fingerprint}" && -z "${SEEN_KEYS[${fingerprint}]}" ]]; then
            SEEN_KEYS[${fingerprint}]=1
            KEY_OPTIONS+=("file: ${pubfile}")
            KEY_SOURCES+=("file:${pubfile}")
        fi
    done < <(find ~/.ssh -name '*.pub' -type f 2>/dev/null)

    if [[ ${#KEY_OPTIONS[@]} -eq 0 ]]; then
        error "No public keys found in ssh-agent or ~/.ssh/"
        return
    fi

    local choice
    if ! choice=$(wizard choose "Select public key to upload" "${KEY_OPTIONS[@]}" --default "${KEY_OPTIONS[0]}"); then return; fi

    local source=""
    for i in "${!KEY_OPTIONS[@]}"; do
        if [[ "${KEY_OPTIONS[$i]}" == "${choice}" ]]; then
            source="${KEY_SOURCES[$i]}"
            break
        fi
    done

    local keyname
    ask "Enter a name for this key" keyname "${GUMDROP_SSH_KEY_NAME}"

    if [[ "${source}" == agent:* ]]; then
        local pubkey_data="${source#agent:}"
        local tmpfile=$(mktemp)
        echo "${pubkey_data}" > "${tmpfile}"
        doctl compute ssh-key import "${keyname}" --public-key-file "${tmpfile}"
        rm -f "${tmpfile}"
    else
        local pubfile="${source#file:}"
        doctl compute ssh-key import "${keyname}" --public-key-file "${pubfile}"
    fi
    echo "SSH key '${keyname}' uploaded."
}

gumdrop_delete_ssh_key() {
    readarray -t SSH_KEY_IDS < <(doctl compute ssh-key list --format ID --no-header)
    readarray -t SSH_KEY_NAMES < <(doctl compute ssh-key list --format Name --no-header)
    if [[ ${#SSH_KEY_IDS[@]} -eq 0 ]]; then
        echo "No SSH keys found."
        return
    fi
    local KEY_OPTIONS=()
    for i in "${!SSH_KEY_IDS[@]}"; do
        KEY_OPTIONS+=("${SSH_KEY_NAMES[$i]} (${SSH_KEY_IDS[$i]})")
    done
    local choice
    if ! choice=$(wizard choose "Delete which SSH key?" "${KEY_OPTIONS[@]}" --default "${KEY_OPTIONS[0]}"); then return; fi
    local key_id=$(echo "${choice}" | grep -oP '\(\K[0-9]+(?=\))')
    confirm no "Are you sure you want to delete '${choice}'" "?" || return
    doctl compute ssh-key delete "${key_id}" --force
    echo "SSH key deleted."
}

gumdrop_list_ssh_keys() {
    echo ""
    echo "## SSH keys:"
    doctl compute ssh-key list --format ID,Name,FingerPrint
    echo ""
}

gumdrop_manage_ssh_keys() {
    while :
    do
        gumdrop_list_ssh_keys
        set +e
        wizard menu --once --cancel-code=2 "SSH Keys:" \
            "Upload SSH key = $0 gumdrop_upload_ssh_key" \
            "Delete SSH key = $0 gumdrop_delete_ssh_key" \
            "Back = exit 2"
        local EXIT_CODE=$?
        set -e
        if [[ "${EXIT_CODE}" == "2" ]]; then
            exit 0
        fi
    done
}

_gumdrop_create_web_firewall() {
    local fw_name="${DROPLET_NAME}-web-$(head -c4 /dev/urandom | od -An -tx1 | tr -d ' ')"
    echo "Creating firewall '${fw_name}' (TCP 22, 80, 443 inbound, all outbound)..."
    local output
    output=$(doctl compute firewall create \
        --name "${fw_name}" \
        --inbound-rules "protocol:tcp,ports:22,address:0.0.0.0/0,address:::/0 protocol:tcp,ports:80,address:0.0.0.0/0,address:::/0 protocol:tcp,ports:443,address:0.0.0.0/0,address:::/0 protocol:icmp,address:0.0.0.0/0,address:::/0" \
        --outbound-rules "protocol:tcp,ports:all,address:0.0.0.0/0,address:::/0 protocol:udp,ports:all,address:0.0.0.0/0,address:::/0 protocol:icmp,address:0.0.0.0/0,address:::/0" \
        --format ID,Name --no-header)
    local fw_id=$(echo "${output}" | awk '{print $1}')
    if [[ -n "${fw_id}" ]]; then
        FIREWALL_IDS+=("${fw_id}")
        FIREWALL_NAMES+=("${fw_name}")
        echo "Firewall '${fw_name}' created."
    else
        error "Failed to create firewall."
    fi
}

_gumdrop_choose_existing_firewalls() {
    readarray -t FW_IDS < <(doctl compute firewall list --format ID --no-header)
    readarray -t FW_NAMES < <(doctl compute firewall list --format Name --no-header)
    if [[ ${#FW_IDS[@]} -eq 0 ]]; then
        echo "No existing firewalls found."
        return
    fi
    local FW_OPTIONS=()
    for i in "${!FW_IDS[@]}"; do
        FW_OPTIONS+=("${FW_NAMES[$i]} (${FW_IDS[$i]})")
    done
    readarray -t SELECTED < <(wizard select "Select firewalls to apply" "${FW_OPTIONS[@]}")
    for choice in "${SELECTED[@]}"; do
        local fw_id=$(echo "${choice}" | grep -oP '\(\K[0-9a-f-]+(?=\))')
        local fw_name=$(echo "${choice}" | sed 's/ ([^)]*)//')
        if [[ -n "${fw_id}" ]]; then
            FIREWALL_IDS+=("${fw_id}")
            FIREWALL_NAMES+=("${fw_name}")
        fi
    done
}

_gumdrop_create_custom_firewall() {
    local fw_name
    ask_no_blank "Enter firewall name" fw_name
    local INBOUND_RULES=()
    local OUTBOUND_RULES=()

    ## Always allow all outbound by default:
    OUTBOUND_RULES+=("protocol:tcp,ports:all,address:0.0.0.0/0,address:::/0")
    OUTBOUND_RULES+=("protocol:udp,ports:all,address:0.0.0.0/0,address:::/0")
    OUTBOUND_RULES+=("protocol:icmp,address:0.0.0.0/0,address:::/0")

    while :; do
        echo ""
        echo "## Inbound rules for '${fw_name}':"
        if [[ ${#INBOUND_RULES[@]} -gt 0 ]]; then
            for rule in "${INBOUND_RULES[@]}"; do
                local proto=$(echo "${rule}" | grep -oP 'protocol:\K[^,]+')
                local port=$(echo "${rule}" | grep -oP 'ports:\K[^,]+')
                if [[ "${proto}" == "icmp" ]]; then
                    echo "  ${proto}"
                else
                    echo "  ${proto}/${port}"
                fi
            done
        else
            echo "  (none)"
        fi
        local rule_action
        set +e
        rule_action=$(wizard choose "Manage inbound rules" \
            "Add TCP port(s)" \
            "Add UDP port(s)" \
            "Allow ICMP (ping)" \
            "Delete rule(s)" \
            "Done" \
            --default "Done")
        local rule_exit=$?
        set -e
        if [[ ${rule_exit} -ne 0 ]]; then
            return
        elif [[ "${rule_action}" == "Done" ]]; then
            break
        elif [[ "${rule_action}" == "Delete rule(s)" ]]; then
            if [[ ${#INBOUND_RULES[@]} -eq 0 ]]; then
                echo "No rules to delete."
            else
                local DELETE_OPTIONS=()
                for rule in "${INBOUND_RULES[@]}"; do
                    local proto=$(echo "${rule}" | grep -oP 'protocol:\K[^,]+')
                    local port=$(echo "${rule}" | grep -oP 'ports:\K[^,]+')
                    if [[ "${proto}" == "icmp" ]]; then
                        DELETE_OPTIONS+=("${proto}")
                    else
                        DELETE_OPTIONS+=("${proto}/${port}")
                    fi
                done
                readarray -t TO_DELETE < <(wizard select "Select rules to delete" "${DELETE_OPTIONS[@]}")
                if [[ ${#TO_DELETE[@]} -gt 0 ]]; then
                    local NEW_RULES=()
                    for i in "${!INBOUND_RULES[@]}"; do
                        local keep=true
                        for del in "${TO_DELETE[@]}"; do
                            [[ "${DELETE_OPTIONS[$i]}" == "${del}" ]] && keep=false
                        done
                        [[ "${keep}" == true ]] && NEW_RULES+=("${INBOUND_RULES[$i]}")
                    done
                    INBOUND_RULES=("${NEW_RULES[@]}")
                fi
            fi
        elif [[ "${rule_action}" == "Add TCP port(s)" ]]; then
            local ports_input
            ask_no_blank "Enter TCP port(s) (e.g. 22 or 80,443 or 8000-9000)" ports_input
            IFS=',' read -ra PORT_LIST <<< "${ports_input}"
            for port in "${PORT_LIST[@]}"; do
                port=$(echo "${port}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                [[ -n "${port}" ]] && INBOUND_RULES+=("protocol:tcp,ports:${port},address:0.0.0.0/0,address:::/0")
            done
        elif [[ "${rule_action}" == "Add UDP port(s)" ]]; then
            local ports_input
            ask_no_blank "Enter UDP port(s) (e.g. 53 or 1194,5353)" ports_input
            IFS=',' read -ra PORT_LIST <<< "${ports_input}"
            for port in "${PORT_LIST[@]}"; do
                port=$(echo "${port}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                [[ -n "${port}" ]] && INBOUND_RULES+=("protocol:udp,ports:${port},address:0.0.0.0/0,address:::/0")
            done
        elif [[ "${rule_action}" == "Allow ICMP (ping)" ]]; then
            INBOUND_RULES+=("protocol:icmp,address:0.0.0.0/0,address:::/0")
            echo "ICMP added."
        fi
    done

    if [[ ${#INBOUND_RULES[@]} -eq 0 ]]; then
        echo "No inbound rules added. Skipping firewall creation."
        return
    fi

    local inbound_str="${INBOUND_RULES[*]}"
    local outbound_str="${OUTBOUND_RULES[*]}"

    echo "Creating firewall '${fw_name}'..."
    local output
    output=$(doctl compute firewall create \
        --name "${fw_name}" \
        --inbound-rules "${inbound_str}" \
        --outbound-rules "${outbound_str}" \
        --format ID,Name --no-header)
    local fw_id=$(echo "${output}" | awk '{print $1}')
    if [[ -n "${fw_id}" ]]; then
        FIREWALL_IDS+=("${fw_id}")
        FIREWALL_NAMES+=("${fw_name}")
        echo "Firewall '${fw_name}' created."
    else
        error "Failed to create firewall."
    fi
}

gumdrop_create() {
    if ! gumdrop_ensure_ssh_key; then return; fi

    ## Call pre-create hook if defined:
    if type -t gumdrop_pre_create_hook &>/dev/null; then
        gumdrop_pre_create_hook
    fi

    ask_no_blank "Enter ${GUMDROP_LABEL,,} name" DROPLET_NAME

    ## Select region:
    readarray -t REGION_SLUGS < <(doctl compute region list --format Slug --no-header)
    readarray -t REGION_NAMES < <(doctl compute region list --format Name --no-header)
    REGION_OPTIONS=()
    REGION_DEFAULT=""
    for i in "${!REGION_SLUGS[@]}"; do
        local opt=$(printf "%-8s  %s" "${REGION_SLUGS[$i]}" "${REGION_NAMES[$i]}")
        REGION_OPTIONS+=("${opt}")
        [[ "${REGION_SLUGS[$i]}" == "${GUMDROP_DEFAULT_REGION}" ]] && REGION_DEFAULT="${opt}"
    done
    REGION_CHOICE=$(wizard choose "Select region" "${REGION_OPTIONS[@]}" --default "${REGION_DEFAULT}")
    REGION=$(echo "${REGION_CHOICE}" | awk '{print $1}')

    ## Select size:
    readarray -t SIZE_SLUGS < <(doctl compute size list --format Slug --no-header)
    readarray -t SIZE_PRICES < <(doctl compute size list --format PriceHourly --no-header)
    readarray -t SIZE_DISKS < <(doctl compute size list --format Disk --no-header)
    readarray -t SIZE_VCPUS < <(doctl compute size list --format VCPUs --no-header)
    SIZE_OPTIONS=()
    SIZE_DEFAULT=""
    for i in "${!SIZE_SLUGS[@]}"; do
        local opt=$(printf "%-25s  %-3s vCPUs  \$%-10s  %sGB disk" "${SIZE_SLUGS[$i]}" "${SIZE_VCPUS[$i]}" "${SIZE_PRICES[$i]}/hr" "${SIZE_DISKS[$i]}")
        SIZE_OPTIONS+=("${opt}")
        [[ "${SIZE_SLUGS[$i]}" == "${GUMDROP_DEFAULT_SIZE}" ]] && SIZE_DEFAULT="${opt}"
    done
    SIZE_CHOICE=$(wizard choose "Select size" "${SIZE_OPTIONS[@]}" --default "${SIZE_DEFAULT}")
    SIZE=$(echo "${SIZE_CHOICE}" | awk '{print $1}')

    ## Select image:
    local IMAGE_OPTIONS=()
    local IMAGE_DEFAULT=""
    if [[ -n "${GUMDROP_IMAGES}" ]]; then
        read -ra IMAGE_OPTIONS <<< "${GUMDROP_IMAGES}"
    else
        while IFS=$'\t' read -r slug distro; do
            [[ -n "${slug}" ]] && IMAGE_OPTIONS+=("$(printf "%-30s  %s" "${slug}" "${distro}")")
        done < <(doctl compute image list --public --format Slug,Distribution --no-header | grep -v '^\s*$' | sort)
    fi
    for opt in "${IMAGE_OPTIONS[@]}"; do
        [[ "$(echo "${opt}" | awk '{print $1}')" == "${GUMDROP_DEFAULT_IMAGE}" ]] && IMAGE_DEFAULT="${opt}"
    done
    local IMAGE_CHOICE
    IMAGE_CHOICE=$(wizard choose "Select image" "${IMAGE_OPTIONS[@]}" --default "${IMAGE_DEFAULT}")
    IMAGE=$(echo "${IMAGE_CHOICE}" | awk '{print $1}')

    ## Select SSH key:
    echo ""
    readarray -t SSH_KEY_IDS < <(doctl compute ssh-key list --format ID --no-header)
    readarray -t SSH_KEY_NAMES < <(doctl compute ssh-key list --format Name --no-header)
    SSH_KEY_OPTIONS=()
    for i in "${!SSH_KEY_IDS[@]}"; do
        SSH_KEY_OPTIONS+=("${SSH_KEY_NAMES[$i]} (${SSH_KEY_IDS[$i]})")
    done
    local SSH_KEY_CHOICE
    if ! SSH_KEY_CHOICE=$(wizard choose "Which SSH key?" "${SSH_KEY_OPTIONS[@]}" --default "${SSH_KEY_OPTIONS[0]}"); then return; fi
    SSH_KEY=$(echo "${SSH_KEY_CHOICE}" | grep -oP '\(\K[0-9]+(?=\))')

    ## Select tags:
    local DROPLET_TAGS=()
    if [[ -n "${GUMDROP_TAG}" ]]; then
        DROPLET_TAGS+=("${GUMDROP_TAG}")
    else
        if confirm no "Add tags to this ${GUMDROP_LABEL,,}" "?"; then
            while :; do
                echo ""
                if [[ ${#DROPLET_TAGS[@]} -gt 0 ]]; then
                    echo "  Tags: ${DROPLET_TAGS[*]}"
                else
                    echo "  Tags: (none)"
                fi
                local tag_action
                set +e
                tag_action=$(wizard choose "Manage tags" \
                    "Choose existing tags" \
                    "Add new tags" \
                    "Done" \
                    --default "Done")
                local tag_exit=$?
                set -e
                if [[ ${tag_exit} -ne 0 ]] || [[ "${tag_action}" == "Done" ]]; then
                    break
                elif [[ "${tag_action}" == "Choose existing tags" ]]; then
                    readarray -t EXISTING_TAGS < <(doctl compute droplet list --format Tags --no-header 2>/dev/null | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$' | sort -u)
                    if [[ ${#EXISTING_TAGS[@]} -eq 0 ]]; then
                        echo "No existing tags found on any droplets."
                    else
                        readarray -t SELECTED < <(wizard select "Select tags to add" "${EXISTING_TAGS[@]}")
                        for tag in "${SELECTED[@]}"; do
                            local already=false
                            for existing in "${DROPLET_TAGS[@]}"; do
                                [[ "${existing}" == "${tag}" ]] && already=true
                            done
                            [[ "${already}" == false ]] && DROPLET_TAGS+=("${tag}")
                        done
                    fi
                elif [[ "${tag_action}" == "Add new tags" ]]; then
                    local new_tags_input
                    ask_no_blank "Enter tags (comma separated)" new_tags_input
                    IFS=',' read -ra NEW_TAGS <<< "${new_tags_input}"
                    for raw_tag in "${NEW_TAGS[@]}"; do
                        local tag=$(echo "${raw_tag}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                        [[ -z "${tag}" ]] && continue
                        local already=false
                        for existing in "${DROPLET_TAGS[@]}"; do
                            [[ "${existing}" == "${tag}" ]] && already=true
                        done
                        [[ "${already}" == false ]] && DROPLET_TAGS+=("${tag}")
                    done
                fi
            done
        fi
    fi

    ## Select firewall:
    local FIREWALL_IDS=()
    local FIREWALL_NAMES=()
    local fw_action
    set +e
    fw_action=$(wizard choose "Firewall" \
        "No firewall" \
        "Web (SSH + HTTP + HTTPS)" \
        "Choose existing firewall" \
        "Create new firewall" \
        --default "No firewall")
    set -e
    if [[ "${fw_action}" == "Web (SSH + HTTP + HTTPS)" ]]; then
        _gumdrop_create_web_firewall
    elif [[ "${fw_action}" == "Choose existing firewall" ]]; then
        _gumdrop_choose_existing_firewalls
    elif [[ "${fw_action}" == "Create new firewall" ]]; then
        _gumdrop_create_custom_firewall
    fi

    ## Select reserved IP:
    local RESERVED_IP=""
    if confirm no "Assign a reserved IP address" "?"; then
        while :; do
            ## Collect unassigned IPs:
            readarray -t ALL_IPS < <(doctl compute reserved-ip list --format IP --no-header 2>/dev/null)
            readarray -t ALL_DROPLET_IDS < <(doctl compute reserved-ip list --format DropletID --no-header 2>/dev/null)
            local UNASSIGNED_IPS=()
            for i in "${!ALL_IPS[@]}"; do
                if [[ -z "${ALL_DROPLET_IDS[$i]}" || "${ALL_DROPLET_IDS[$i]}" == "0" ]]; then
                    UNASSIGNED_IPS+=("${ALL_IPS[$i]}")
                fi
            done

            ## Build menu options:
            local rip_options=("Create new reserved IP")
            if [[ ${#UNASSIGNED_IPS[@]} -gt 0 ]]; then
                rip_options+=("Choose existing reserved IP")
            else
                echo "No unassigned reserved IPs available."
            fi
            rip_options+=("Skip")

            local rip_action
            set +e
            rip_action=$(wizard choose "Reserved IP" "${rip_options[@]}" --default "${rip_options[0]}")
            set -e

            if [[ "${rip_action}" == "Create new reserved IP" ]]; then
                gumdrop_create_reserved_ip
                continue
            elif [[ "${rip_action}" == "Choose existing reserved IP" ]]; then
                local ip_choice
                if ip_choice=$(wizard choose "Select reserved IP" "${UNASSIGNED_IPS[@]}" --default "${UNASSIGNED_IPS[0]}"); then
                    RESERVED_IP="${ip_choice}"
                fi
                break
            else
                break
            fi
        done
    fi

    ## Generate user-data via hook if defined:
    local user_data_args=()
    if type -t gumdrop_user_data_hook &>/dev/null; then
        USER_DATA=$(gumdrop_user_data_hook)
        user_data_args=(--user-data "${USER_DATA}")
    fi

    ## Build tag args:
    local tag_args=()
    if [[ ${#DROPLET_TAGS[@]} -gt 0 ]]; then
        local tag_csv
        tag_csv=$(IFS=','; echo "${DROPLET_TAGS[*]}")
        tag_args=(--tag-names "${tag_csv}")
    fi

    echo ""
    echo "## Summary:"
    echo "  ${GUMDROP_LABEL} name:  ${DROPLET_NAME}"
    echo "  Region:        ${REGION}"
    echo "  Size:          ${SIZE}"
    echo "  Image:         ${IMAGE}"
    echo "  SSH key:       ${SSH_KEY}"
    echo "  Tags:          ${DROPLET_TAGS[*]:-(none)}"
    echo "  Firewall:      ${FIREWALL_NAMES[*]:-(none)}"
    echo "  Reserved IP:   ${RESERVED_IP:-(none)}"

    ## Call summary hook if defined:
    if type -t gumdrop_summary_hook &>/dev/null; then
        gumdrop_summary_hook
    fi

    echo ""
    confirm yes "Create this ${GUMDROP_LABEL,,}" "?" || return

    echo "Creating ${GUMDROP_LABEL,,} '${DROPLET_NAME}', please wait..."
    doctl compute droplet create "${DROPLET_NAME}" \
        --region "${REGION}" \
        --size "${SIZE}" \
        --image "${IMAGE}" \
        --ssh-keys "${SSH_KEY}" \
        "${user_data_args[@]}" \
        "${tag_args[@]}" \
        --wait

    ## Assign firewalls to the new droplet:
    if [[ ${#FIREWALL_IDS[@]} -gt 0 ]]; then
        local droplet_id=$(doctl compute droplet list --format ID,Name --no-header | awk -v name="${DROPLET_NAME}" '$2 == name {print $1}')
        if [[ -n "${droplet_id}" ]]; then
            for fw_id in "${FIREWALL_IDS[@]}"; do
                doctl compute firewall add-droplets "${fw_id}" --droplet-ids "${droplet_id}"
            done
        fi
    fi

    ## Assign reserved IP to the new droplet:
    if [[ -n "${RESERVED_IP}" ]]; then
        local droplet_id=${droplet_id:-$(doctl compute droplet list --format ID,Name --no-header | awk -v name="${DROPLET_NAME}" '$2 == name {print $1}')}
        if [[ -n "${droplet_id}" ]]; then
            echo "Assigning reserved IP ${RESERVED_IP}..."
            doctl compute reserved-ip-action assign "${RESERVED_IP}" "${droplet_id}"
        fi
    fi

    echo ""
    echo "${GUMDROP_LABEL} created."
    echo "Check cloud-init status with: doctl compute ssh ${DROPLET_NAME} -- tail -f /var/log/cloud-init-output.log"
    gumdrop_list
}

gumdrop_list_firewalls() {
    echo ""
    echo "## Firewalls:"
    doctl compute firewall list --format ID,Name,Status,InboundRules,DropletIDs
    echo ""
}

gumdrop_delete_firewall() {
    readarray -t FW_IDS < <(doctl compute firewall list --format ID --no-header)
    readarray -t FW_NAMES < <(doctl compute firewall list --format Name --no-header)
    if [[ ${#FW_IDS[@]} -eq 0 ]]; then
        echo "No firewalls found."
        return
    fi
    local FW_OPTIONS=()
    for i in "${!FW_IDS[@]}"; do
        FW_OPTIONS+=("${FW_NAMES[$i]} (${FW_IDS[$i]})")
    done
    local choice
    if ! choice=$(wizard choose "Delete which firewall?" "${FW_OPTIONS[@]}" --default "${FW_OPTIONS[0]}"); then return; fi
    local fw_id=$(echo "${choice}" | grep -oP '\(\K[0-9a-f-]+(?=\))')
    confirm no "Are you sure you want to delete '${choice}'" "?" || return
    doctl compute firewall delete "${fw_id}" --force
    echo "Firewall deleted."
}

gumdrop_edit_firewall() {
    readarray -t FW_IDS < <(doctl compute firewall list --format ID --no-header)
    readarray -t FW_NAMES < <(doctl compute firewall list --format Name --no-header)
    if [[ ${#FW_IDS[@]} -eq 0 ]]; then
        echo "No firewalls found."
        return
    fi
    local FW_OPTIONS=()
    for i in "${!FW_IDS[@]}"; do
        FW_OPTIONS+=("${FW_NAMES[$i]} (${FW_IDS[$i]})")
    done
    local choice
    if ! choice=$(wizard choose "Edit which firewall?" "${FW_OPTIONS[@]}" --default "${FW_OPTIONS[0]}"); then return; fi
    local fw_id=$(echo "${choice}" | grep -oP '\(\K[0-9a-f-]+(?=\))')
    local fw_name=$(echo "${choice}" | sed 's/ ([^)]*)//')

    ## Fetch current inbound rules:
    local current_rules=$(doctl compute firewall get "${fw_id}" --format InboundRules --no-header)
    local INBOUND_RULES=()
    if [[ -n "${current_rules}" ]]; then
        while IFS= read -r rule; do
            rule=$(echo "${rule}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [[ -n "${rule}" ]] && INBOUND_RULES+=("${rule}")
        done < <(echo "${current_rules}" | tr ' ' '\n')
    fi

    while :; do
        echo ""
        echo "## Inbound rules for '${fw_name}':"
        if [[ ${#INBOUND_RULES[@]} -gt 0 ]]; then
            for rule in "${INBOUND_RULES[@]}"; do
                local proto=$(echo "${rule}" | grep -oP 'protocol:\K[^,]+')
                local port=$(echo "${rule}" | grep -oP 'ports:\K[^,]+')
                if [[ "${proto}" == "icmp" ]]; then
                    echo "  ${proto}"
                else
                    echo "  ${proto}/${port}"
                fi
            done
        else
            echo "  (none)"
        fi
        local rule_action
        set +e
        rule_action=$(wizard choose "Manage inbound rules" \
            "Add TCP port(s)" \
            "Add UDP port(s)" \
            "Allow ICMP (ping)" \
            "Delete rule(s)" \
            "Save" \
            --default "Save")
        local rule_exit=$?
        set -e
        if [[ ${rule_exit} -ne 0 ]]; then
            return
        elif [[ "${rule_action}" == "Save" ]]; then
            break
        elif [[ "${rule_action}" == "Delete rule(s)" ]]; then
            if [[ ${#INBOUND_RULES[@]} -eq 0 ]]; then
                echo "No rules to delete."
            else
                local DELETE_OPTIONS=()
                for rule in "${INBOUND_RULES[@]}"; do
                    local proto=$(echo "${rule}" | grep -oP 'protocol:\K[^,]+')
                    local port=$(echo "${rule}" | grep -oP 'ports:\K[^,]+')
                    if [[ "${proto}" == "icmp" ]]; then
                        DELETE_OPTIONS+=("${proto}")
                    else
                        DELETE_OPTIONS+=("${proto}/${port}")
                    fi
                done
                readarray -t TO_DELETE < <(wizard select "Select rules to delete" "${DELETE_OPTIONS[@]}")
                if [[ ${#TO_DELETE[@]} -gt 0 ]]; then
                    local NEW_RULES=()
                    for i in "${!INBOUND_RULES[@]}"; do
                        local keep=true
                        for del in "${TO_DELETE[@]}"; do
                            [[ "${DELETE_OPTIONS[$i]}" == "${del}" ]] && keep=false
                        done
                        [[ "${keep}" == true ]] && NEW_RULES+=("${INBOUND_RULES[$i]}")
                    done
                    INBOUND_RULES=("${NEW_RULES[@]}")
                fi
            fi
        elif [[ "${rule_action}" == "Add TCP port(s)" ]]; then
            local ports_input
            ask_no_blank "Enter TCP port(s) (e.g. 22 or 80,443 or 8000-9000)" ports_input
            IFS=',' read -ra PORT_LIST <<< "${ports_input}"
            for port in "${PORT_LIST[@]}"; do
                port=$(echo "${port}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                [[ -n "${port}" ]] && INBOUND_RULES+=("protocol:tcp,ports:${port},address:0.0.0.0/0,address:::/0")
            done
        elif [[ "${rule_action}" == "Add UDP port(s)" ]]; then
            local ports_input
            ask_no_blank "Enter UDP port(s) (e.g. 53 or 1194,5353)" ports_input
            IFS=',' read -ra PORT_LIST <<< "${ports_input}"
            for port in "${PORT_LIST[@]}"; do
                port=$(echo "${port}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                [[ -n "${port}" ]] && INBOUND_RULES+=("protocol:udp,ports:${port},address:0.0.0.0/0,address:::/0")
            done
        elif [[ "${rule_action}" == "Allow ICMP (ping)" ]]; then
            INBOUND_RULES+=("protocol:icmp,address:0.0.0.0/0,address:::/0")
            echo "ICMP added."
        fi
    done

    local inbound_str="${INBOUND_RULES[*]}"
    local outbound_str="protocol:tcp,ports:all,address:0.0.0.0/0,address:::/0 protocol:udp,ports:all,address:0.0.0.0/0,address:::/0 protocol:icmp,address:0.0.0.0/0,address:::/0"

    echo "Updating firewall '${fw_name}'..."
    doctl compute firewall update "${fw_id}" \
        --name "${fw_name}" \
        --inbound-rules "${inbound_str}" \
        --outbound-rules "${outbound_str}"
    echo "Firewall '${fw_name}' updated."
}

gumdrop_manage_firewalls() {
    while :
    do
        gumdrop_list_firewalls
        local fw_count=$(doctl compute firewall list --format ID --no-header 2>/dev/null | wc -l)
        local menu_items=(
            "Create new firewall = $0 gumdrop_create_firewall_standalone"
        )
        if [[ ${fw_count} -gt 0 ]]; then
            menu_items+=(
                "Edit firewall = $0 gumdrop_edit_firewall"
                "Delete firewall = $0 gumdrop_delete_firewall"
            )
        fi
        menu_items+=("Back = exit 2")
        set +e
        wizard menu --once --cancel-code=2 "Firewalls:" "${menu_items[@]}"
        local EXIT_CODE=$?
        set -e
        if [[ "${EXIT_CODE}" == "2" ]]; then
            exit 0
        fi
    done
}

gumdrop_list_reserved_ips() {
    echo ""
    echo "## Reserved IPs:"
    local count=$(doctl compute reserved-ip list --format IP --no-header 2>/dev/null | wc -l)
    if [[ ${count} -gt 0 ]]; then
        doctl compute reserved-ip list --format IP,Region,DropletID,DropletName
    else
        echo "No reserved IPs found."
    fi
    echo ""
}

gumdrop_create_reserved_ip() {
    ## Select region:
    readarray -t REGION_SLUGS < <(doctl compute region list --format Slug --no-header)
    readarray -t REGION_NAMES < <(doctl compute region list --format Name --no-header)
    local REGION_OPTIONS=()
    local REGION_DEFAULT=""
    for i in "${!REGION_SLUGS[@]}"; do
        local opt=$(printf "%-8s  %s" "${REGION_SLUGS[$i]}" "${REGION_NAMES[$i]}")
        REGION_OPTIONS+=("${opt}")
        [[ "${REGION_SLUGS[$i]}" == "${GUMDROP_DEFAULT_REGION}" ]] && REGION_DEFAULT="${opt}"
    done
    local choice
    if ! choice=$(wizard choose "Select region for reserved IP" "${REGION_OPTIONS[@]}" --default "${REGION_DEFAULT}"); then return; fi
    local region=$(echo "${choice}" | awk '{print $1}')
    echo "Creating reserved IP in ${region}..."
    doctl compute reserved-ip create --region "${region}"
    echo "Reserved IP created."
}

gumdrop_delete_reserved_ip() {
    readarray -t IPS < <(doctl compute reserved-ip list --format IP --no-header)
    if [[ ${#IPS[@]} -eq 0 ]]; then
        echo "No reserved IPs found."
        return
    fi
    readarray -t IP_DROPLETS < <(doctl compute reserved-ip list --format DropletName --no-header)
    local IP_OPTIONS=()
    for i in "${!IPS[@]}"; do
        if [[ -n "${IP_DROPLETS[$i]}" && "${IP_DROPLETS[$i]}" != "<nil>" ]]; then
            IP_OPTIONS+=("${IPS[$i]} (${IP_DROPLETS[$i]})")
        else
            IP_OPTIONS+=("${IPS[$i]} (unassigned)")
        fi
    done
    local choice
    if ! choice=$(wizard choose "Delete which reserved IP?" "${IP_OPTIONS[@]}" --default "${IP_OPTIONS[0]}"); then return; fi
    local ip=$(echo "${choice}" | awk '{print $1}')
    confirm no "Are you sure you want to delete reserved IP '${ip}'" "?" || return
    doctl compute reserved-ip delete "${ip}" --force
    echo "Reserved IP '${ip}' deleted."
}

gumdrop_assign_reserved_ip() {
    ## List only unassigned IPs:
    readarray -t IPS < <(doctl compute reserved-ip list --format IP --no-header)
    readarray -t IP_DROPLET_IDS < <(doctl compute reserved-ip list --format DropletID --no-header)
    local UNASSIGNED_IPS=()
    for i in "${!IPS[@]}"; do
        if [[ -z "${IP_DROPLET_IDS[$i]}" || "${IP_DROPLET_IDS[$i]}" == "0" ]]; then
            UNASSIGNED_IPS+=("${IPS[$i]}")
        fi
    done
    if [[ ${#UNASSIGNED_IPS[@]} -eq 0 ]]; then
        echo "No unassigned reserved IPs available."
        return
    fi
    local ip_choice
    if ! ip_choice=$(wizard choose "Select reserved IP to assign" "${UNASSIGNED_IPS[@]}" --default "${UNASSIGNED_IPS[0]}"); then return; fi

    ## List droplets to assign to:
    local tag_args=()
    [[ -n "${GUMDROP_TAG}" ]] && tag_args=(--tag-name "${GUMDROP_TAG}")
    readarray -t DROPLET_IDS < <(doctl compute droplet list "${tag_args[@]}" --format ID --no-header)
    readarray -t DROPLET_NAMES < <(doctl compute droplet list "${tag_args[@]}" --format Name --no-header)
    if [[ ${#DROPLET_IDS[@]} -eq 0 ]]; then
        echo "No ${GUMDROP_LABEL,,}s found to assign to."
        return
    fi
    local DROPLET_OPTIONS=()
    for i in "${!DROPLET_IDS[@]}"; do
        DROPLET_OPTIONS+=("${DROPLET_NAMES[$i]} (${DROPLET_IDS[$i]})")
    done
    local droplet_choice
    if ! droplet_choice=$(wizard choose "Assign to which ${GUMDROP_LABEL,,}?" "${DROPLET_OPTIONS[@]}" --default "${DROPLET_OPTIONS[0]}"); then return; fi
    local droplet_id=$(echo "${droplet_choice}" | grep -oP '\(\K[0-9]+(?=\))')

    echo "Assigning ${ip_choice} to ${droplet_choice}..."
    doctl compute reserved-ip-action assign "${ip_choice}" "${droplet_id}"
    echo "Reserved IP assigned."
}

gumdrop_manage_reserved_ips() {
    while :
    do
        gumdrop_list_reserved_ips
        local ip_count=$(doctl compute reserved-ip list --format IP --no-header 2>/dev/null | wc -l)
        local menu_items=(
            "Create reserved IP = $0 gumdrop_create_reserved_ip"
        )
        if [[ ${ip_count} -gt 0 ]]; then
            menu_items+=(
                "Assign reserved IP = $0 gumdrop_assign_reserved_ip"
                "Delete reserved IP = $0 gumdrop_delete_reserved_ip"
            )
        fi
        menu_items+=("Back = exit 2")
        set +e
        wizard menu --once --cancel-code=2 "Reserved IPs:" "${menu_items[@]}"
        local EXIT_CODE=$?
        set -e
        if [[ "${EXIT_CODE}" == "2" ]]; then
            exit 0
        fi
    done
}

gumdrop_create_firewall_standalone() {
    _gumdrop_create_custom_firewall
    if [[ ${#FIREWALL_IDS[@]} -gt 0 ]]; then
        echo ""
        echo "Firewall created. Assign it to droplets from the create menu or via doctl."
    fi
}

gumdrop_list_accounts() {
    echo ""
    echo "## Accounts:"
    doctl auth list 2>/dev/null
    echo ""
}

gumdrop_switch_account() {
    readarray -t CONTEXTS < <(doctl auth list 2>/dev/null | sed 's/ (current)$//')
    if [[ ${#CONTEXTS[@]} -le 1 ]]; then
        echo "Only one account configured."
        return
    fi
    local current=$(doctl auth list 2>/dev/null | grep -oP '^.+(?= \(current\))')
    local choice
    if ! choice=$(wizard choose "Switch to which account?" "${CONTEXTS[@]}" --default "${current}"); then return; fi
    doctl auth switch --context "${choice}"
    echo "Switched to account: ${choice}"
}

gumdrop_add_account() {
    local context_name
    ask_no_blank "Enter a name for this account" context_name
    doctl auth init --context "${context_name}"
    echo "Account '${context_name}' added."
    doctl auth switch --context "${context_name}"
    echo "Switched to account: ${context_name}"
}

gumdrop_remove_account() {
    readarray -t CONTEXTS < <(doctl auth list 2>/dev/null | sed 's/ (current)$//')
    if [[ ${#CONTEXTS[@]} -eq 0 ]]; then
        echo "No accounts configured."
        return
    fi
    local choice
    if ! choice=$(wizard choose "Remove which account?" "${CONTEXTS[@]}" --default "${CONTEXTS[0]}"); then return; fi
    confirm no "Are you sure you want to remove account '${choice}'" "?" || return
    doctl auth remove --context "${choice}"
    echo "Account '${choice}' removed."
}

gumdrop_manage_accounts() {
    while :
    do
        gumdrop_list_accounts
        set +e
        wizard menu --once --cancel-code=2 "Accounts:" \
            "Switch account = $0 gumdrop_switch_account" \
            "Add account = $0 gumdrop_add_account" \
            "Remove account = $0 gumdrop_remove_account" \
            "Back = exit 2"
        local EXIT_CODE=$?
        set -e
        if [[ "${EXIT_CODE}" == "2" ]]; then
            exit 0
        fi
    done
}

gumdrop_main() {
    gumdrop_check_doctl
    while :
    do
        gumdrop_check_doctl
        gumdrop_list
        set +e
        wizard menu --once --cancel-code=2 "${GUMDROP_LABEL}s:" \
            "Create new ${GUMDROP_LABEL,,} = $0 gumdrop_create" \
            "SSH into ${GUMDROP_LABEL,,} = $0 gumdrop_ssh" \
            "Destroy ${GUMDROP_LABEL,,} = $0 gumdrop_destroy" \
            "Manage SSH keys = $0 gumdrop_manage_ssh_keys" \
            "Manage firewalls = $0 gumdrop_manage_firewalls" \
            "Manage reserved IPs = $0 gumdrop_manage_reserved_ips" \
            "Manage accounts = $0 gumdrop_manage_accounts" \
            "Exit = exit 2"
        local EXIT_CODE=$?
        set -e
        if [[ "${EXIT_CODE}" == "2" ]]; then
            exit 0
        fi
    done
}

## Parse CLI args when run directly:
_gumdrop_parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tag)
                export GUMDROP_TAG="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done
    GUMDROP_REMAINING_ARGS=("$@")
}

## Direct execution dispatch:
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    _gumdrop_parse_args "$@"
    if [[ ${#GUMDROP_REMAINING_ARGS[@]} -gt 0 ]]; then
        "${GUMDROP_REMAINING_ARGS[@]}"
    else
        gumdrop_main
    fi
fi
